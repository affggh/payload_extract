// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/update_metadata.proto

package update_engine

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InstallOperation_Type int32

const (
	REPLACE    InstallOperation_Type = 0
	REPLACE_BZ InstallOperation_Type = 1
	MOVE       InstallOperation_Type = 2 // Deprecated: Do not use.
	BSDIFF     InstallOperation_Type = 3 // Deprecated: Do not use.
	// On minor version 2 or newer, these operations are supported:
	SOURCE_COPY   InstallOperation_Type = 4
	SOURCE_BSDIFF InstallOperation_Type = 5
	// On minor version 3 or newer and on major version 2 or newer, these
	// operations are supported:
	REPLACE_XZ InstallOperation_Type = 8
	// On minor version 4 or newer, these operations are supported:
	ZERO          InstallOperation_Type = 6
	DISCARD       InstallOperation_Type = 7
	BROTLI_BSDIFF InstallOperation_Type = 10
	// On minor version 5 or newer, these operations are supported:
	PUFFDIFF InstallOperation_Type = 9
	// On minor version 8 or newer, these operations are supported:
	ZUCCHINI InstallOperation_Type = 11
	// On minor version 9 or newer, these operations are supported:
	LZ4DIFF_BSDIFF   InstallOperation_Type = 12
	LZ4DIFF_PUFFDIFF InstallOperation_Type = 13
)

var InstallOperation_Type_name = map[int32]string{
	0:  "REPLACE",
	1:  "REPLACE_BZ",
	2:  "MOVE",
	3:  "BSDIFF",
	4:  "SOURCE_COPY",
	5:  "SOURCE_BSDIFF",
	8:  "REPLACE_XZ",
	6:  "ZERO",
	7:  "DISCARD",
	10: "BROTLI_BSDIFF",
	9:  "PUFFDIFF",
	11: "ZUCCHINI",
	12: "LZ4DIFF_BSDIFF",
	13: "LZ4DIFF_PUFFDIFF",
}

var InstallOperation_Type_value = map[string]int32{
	"REPLACE":          0,
	"REPLACE_BZ":       1,
	"MOVE":             2,
	"BSDIFF":           3,
	"SOURCE_COPY":      4,
	"SOURCE_BSDIFF":    5,
	"REPLACE_XZ":       8,
	"ZERO":             6,
	"DISCARD":          7,
	"BROTLI_BSDIFF":    10,
	"PUFFDIFF":         9,
	"ZUCCHINI":         11,
	"LZ4DIFF_BSDIFF":   12,
	"LZ4DIFF_PUFFDIFF": 13,
}

func (x InstallOperation_Type) Enum() *InstallOperation_Type {
	p := new(InstallOperation_Type)
	*p = x
	return p
}

func (x InstallOperation_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(InstallOperation_Type_name, int32(x))
}

func (x *InstallOperation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstallOperation_Type_value, data, "InstallOperation_Type")
	if err != nil {
		return err
	}
	*x = InstallOperation_Type(value)
	return nil
}

func (InstallOperation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{3, 0}
}

type CowMergeOperation_Type int32

const (
	COW_COPY    CowMergeOperation_Type = 0
	COW_XOR     CowMergeOperation_Type = 1
	COW_REPLACE CowMergeOperation_Type = 2
)

var CowMergeOperation_Type_name = map[int32]string{
	0: "COW_COPY",
	1: "COW_XOR",
	2: "COW_REPLACE",
}

var CowMergeOperation_Type_value = map[string]int32{
	"COW_COPY":    0,
	"COW_XOR":     1,
	"COW_REPLACE": 2,
}

func (x CowMergeOperation_Type) Enum() *CowMergeOperation_Type {
	p := new(CowMergeOperation_Type)
	*p = x
	return p
}

func (x CowMergeOperation_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(CowMergeOperation_Type_name, int32(x))
}

func (x *CowMergeOperation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CowMergeOperation_Type_value, data, "CowMergeOperation_Type")
	if err != nil {
		return err
	}
	*x = CowMergeOperation_Type(value)
	return nil
}

func (CowMergeOperation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{4, 0}
}

// Data is packed into blocks on disk, always starting from the beginning
// of the block. If a file's data is too large for one block, it overflows
// into another block, which may or may not be the following block on the
// physical partition. An ordered list of extents is another
// representation of an ordered list of blocks. For example, a file stored
// in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
// extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
// In general, files are stored sequentially on disk, so it's more efficient
// to use extents to encode the block lists (this is effectively
// run-length encoding).
// A sentinel value (kuint64max) as the start block denotes a sparse-hole
// in a file whose block-length is specified by num_blocks.
type Extent struct {
	StartBlock uint64 `protobuf:"varint,1,opt,name=start_block,json=startBlock" json:"start_block"`
	NumBlocks  uint64 `protobuf:"varint,2,opt,name=num_blocks,json=numBlocks" json:"num_blocks"`
}

func (m *Extent) Reset()      { *m = Extent{} }
func (*Extent) ProtoMessage() {}
func (*Extent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{0}
}
func (m *Extent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Extent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extent.Merge(m, src)
}
func (m *Extent) XXX_Size() int {
	return m.Size()
}
func (m *Extent) XXX_DiscardUnknown() {
	xxx_messageInfo_Extent.DiscardUnknown(m)
}

var xxx_messageInfo_Extent proto.InternalMessageInfo

func (m *Extent) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *Extent) GetNumBlocks() uint64 {
	if m != nil {
		return m.NumBlocks
	}
	return 0
}

// Signatures: Updates may be signed by the OS vendor. The client verifies
// an update's signature by hashing the entire download. The section of the
// download that contains the signature is at the end of the file, so when
// signing a file, only the part up to the signature part is signed.
// Then, the client looks inside the download's Signatures message for a
// Signature message that it knows how to handle. Generally, a client will
// only know how to handle one type of signature, but an update may contain
// many signatures to support many different types of client. Then client
// selects a Signature message and uses that, along with a known public key,
// to verify the download. The public key is expected to be part of the
// client.
type Signatures struct {
	Signatures []*Signatures_Signature `protobuf:"bytes,1,rep,name=signatures" json:"signatures,omitempty"`
}

func (m *Signatures) Reset()      { *m = Signatures{} }
func (*Signatures) ProtoMessage() {}
func (*Signatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{1}
}
func (m *Signatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signatures.Merge(m, src)
}
func (m *Signatures) XXX_Size() int {
	return m.Size()
}
func (m *Signatures) XXX_DiscardUnknown() {
	xxx_messageInfo_Signatures.DiscardUnknown(m)
}

var xxx_messageInfo_Signatures proto.InternalMessageInfo

func (m *Signatures) GetSignatures() []*Signatures_Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signatures_Signature struct {
	Version uint32 `protobuf:"varint,1,opt,name=version" json:"version"` // Deprecated: Do not use.
	Data    []byte `protobuf:"bytes,2,opt,name=data" json:"data"`
	// The DER encoded signature size of EC keys is nondeterministic for
	// different input of sha256 hash. However, we need the size of the
	// serialized signatures protobuf string to be fixed before signing;
	// because this size is part of the content to be signed. Therefore, we
	// always pad the signature data to the maximum possible signature size of
	// a given key. And the payload verifier will truncate the signature to
	// its correct size based on the value of |unpadded_signature_size|.
	UnpaddedSignatureSize uint32 `protobuf:"fixed32,3,opt,name=unpadded_signature_size,json=unpaddedSignatureSize" json:"unpadded_signature_size"`
}

func (m *Signatures_Signature) Reset()      { *m = Signatures_Signature{} }
func (*Signatures_Signature) ProtoMessage() {}
func (*Signatures_Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{1, 0}
}
func (m *Signatures_Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signatures_Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signatures_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signatures_Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signatures_Signature.Merge(m, src)
}
func (m *Signatures_Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signatures_Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signatures_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signatures_Signature proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *Signatures_Signature) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Signatures_Signature) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Signatures_Signature) GetUnpaddedSignatureSize() uint32 {
	if m != nil {
		return m.UnpaddedSignatureSize
	}
	return 0
}

type PartitionInfo struct {
	Size_ uint64 `protobuf:"varint,1,opt,name=size" json:"size"`
	Hash  []byte `protobuf:"bytes,2,opt,name=hash" json:"hash"`
}

func (m *PartitionInfo) Reset()      { *m = PartitionInfo{} }
func (*PartitionInfo) ProtoMessage() {}
func (*PartitionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{2}
}
func (m *PartitionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionInfo.Merge(m, src)
}
func (m *PartitionInfo) XXX_Size() int {
	return m.Size()
}
func (m *PartitionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionInfo proto.InternalMessageInfo

func (m *PartitionInfo) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PartitionInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type InstallOperation struct {
	Type InstallOperation_Type `protobuf:"varint,1,req,name=type,enum=chromeos_update_engine.InstallOperation_Type" json:"type"`
	// Only minor version 6 or newer support 64 bits |data_offset| and
	// |data_length|, older client will read them as uint32.
	// The offset into the delta file (after the protobuf)
	// where the data (if any) is stored
	DataOffset uint64 `protobuf:"varint,2,opt,name=data_offset,json=dataOffset" json:"data_offset"`
	// The length of the data in the delta file
	DataLength uint64 `protobuf:"varint,3,opt,name=data_length,json=dataLength" json:"data_length"`
	// Ordered list of extents that are read from (if any) and written to.
	SrcExtents []*Extent `protobuf:"bytes,4,rep,name=src_extents,json=srcExtents" json:"src_extents,omitempty"`
	// Byte length of src, equal to the number of blocks in src_extents *
	// block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
	// pass that external program the number of bytes to read from the blocks we
	// pass it.  This is not used in any other operation.
	SrcLength  uint64    `protobuf:"varint,5,opt,name=src_length,json=srcLength" json:"src_length"`
	DstExtents []*Extent `protobuf:"bytes,6,rep,name=dst_extents,json=dstExtents" json:"dst_extents,omitempty"`
	// Byte length of dst, equal to the number of blocks in dst_extents *
	// block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
	// operation.
	DstLength uint64 `protobuf:"varint,7,opt,name=dst_length,json=dstLength" json:"dst_length"`
	// Optional SHA 256 hash of the blob associated with this operation.
	// This is used as a primary validation for http-based downloads and
	// as a defense-in-depth validation for https-based downloads. If
	// the operation doesn't refer to any blob, this field will have
	// zero bytes.
	DataSha256Hash []byte `protobuf:"bytes,8,opt,name=data_sha256_hash,json=dataSha256Hash" json:"data_sha256_hash"`
	// Indicates the SHA 256 hash of the source data referenced in src_extents at
	// the time of applying the operation. If present, the update_engine daemon
	// MUST read and verify the source data before applying the operation.
	SrcSha256Hash []byte `protobuf:"bytes,9,opt,name=src_sha256_hash,json=srcSha256Hash" json:"src_sha256_hash"`
}

func (m *InstallOperation) Reset()      { *m = InstallOperation{} }
func (*InstallOperation) ProtoMessage() {}
func (*InstallOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{3}
}
func (m *InstallOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallOperation.Merge(m, src)
}
func (m *InstallOperation) XXX_Size() int {
	return m.Size()
}
func (m *InstallOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallOperation.DiscardUnknown(m)
}

var xxx_messageInfo_InstallOperation proto.InternalMessageInfo

func (m *InstallOperation) GetType() InstallOperation_Type {
	if m != nil {
		return m.Type
	}
	return REPLACE
}

func (m *InstallOperation) GetDataOffset() uint64 {
	if m != nil {
		return m.DataOffset
	}
	return 0
}

func (m *InstallOperation) GetDataLength() uint64 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *InstallOperation) GetSrcExtents() []*Extent {
	if m != nil {
		return m.SrcExtents
	}
	return nil
}

func (m *InstallOperation) GetSrcLength() uint64 {
	if m != nil {
		return m.SrcLength
	}
	return 0
}

func (m *InstallOperation) GetDstExtents() []*Extent {
	if m != nil {
		return m.DstExtents
	}
	return nil
}

func (m *InstallOperation) GetDstLength() uint64 {
	if m != nil {
		return m.DstLength
	}
	return 0
}

func (m *InstallOperation) GetDataSha256Hash() []byte {
	if m != nil {
		return m.DataSha256Hash
	}
	return nil
}

func (m *InstallOperation) GetSrcSha256Hash() []byte {
	if m != nil {
		return m.SrcSha256Hash
	}
	return nil
}

// Hints to VAB snapshot to skip writing some blocks if these blocks are
// identical to the ones on the source image. The src & dst extents for each
// CowMergeOperation should be contiguous, and they're a subset of an OTA
// InstallOperation.
// During merge time, we need to follow the pre-computed sequence to avoid
// read after write, similar to the inplace update schema.
type CowMergeOperation struct {
	Type      CowMergeOperation_Type `protobuf:"varint,1,opt,name=type,enum=chromeos_update_engine.CowMergeOperation_Type" json:"type"`
	SrcExtent *Extent                `protobuf:"bytes,2,opt,name=src_extent,json=srcExtent" json:"src_extent,omitempty"`
	DstExtent *Extent                `protobuf:"bytes,3,opt,name=dst_extent,json=dstExtent" json:"dst_extent,omitempty"`
	// For COW_XOR, source location might be unaligned, so this field is in range
	// [0, block_size), representing how much should the src_extent shift toward
	// larger block number. If this field is non-zero, then src_extent will
	// include 1 extra block in the end, as the merge op actually references the
	// first |src_offset| bytes of that extra block. For example, if |dst_extent|
	// is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
	// Note that |src_extent| contains 1 extra block than the |dst_extent|.
	SrcOffset uint32 `protobuf:"varint,4,opt,name=src_offset,json=srcOffset" json:"src_offset"`
}

func (m *CowMergeOperation) Reset()      { *m = CowMergeOperation{} }
func (*CowMergeOperation) ProtoMessage() {}
func (*CowMergeOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{4}
}
func (m *CowMergeOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CowMergeOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CowMergeOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CowMergeOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CowMergeOperation.Merge(m, src)
}
func (m *CowMergeOperation) XXX_Size() int {
	return m.Size()
}
func (m *CowMergeOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_CowMergeOperation.DiscardUnknown(m)
}

var xxx_messageInfo_CowMergeOperation proto.InternalMessageInfo

func (m *CowMergeOperation) GetType() CowMergeOperation_Type {
	if m != nil {
		return m.Type
	}
	return COW_COPY
}

func (m *CowMergeOperation) GetSrcExtent() *Extent {
	if m != nil {
		return m.SrcExtent
	}
	return nil
}

func (m *CowMergeOperation) GetDstExtent() *Extent {
	if m != nil {
		return m.DstExtent
	}
	return nil
}

func (m *CowMergeOperation) GetSrcOffset() uint32 {
	if m != nil {
		return m.SrcOffset
	}
	return 0
}

// Describes the update to apply to a single partition.
type PartitionUpdate struct {
	// A platform-specific name to identify the partition set being updated. For
	// example, in Chrome OS this could be "ROOT" or "KERNEL".
	PartitionName string `protobuf:"bytes,1,req,name=partition_name,json=partitionName" json:"partition_name"`
	// Whether this partition carries a filesystem with post-install program that
	// must be run to finalize the update process. See also |postinstall_path| and
	// |filesystem_type|.
	RunPostinstall bool `protobuf:"varint,2,opt,name=run_postinstall,json=runPostinstall" json:"run_postinstall"`
	// The path of the executable program to run during the post-install step,
	// relative to the root of this filesystem. If not set, the default "postinst"
	// will be used. This setting is only used when |run_postinstall| is set and
	// true.
	PostinstallPath string `protobuf:"bytes,3,opt,name=postinstall_path,json=postinstallPath" json:"postinstall_path"`
	// The filesystem type as passed to the mount(2) syscall when mounting the new
	// filesystem to run the post-install program. If not set, a fixed list of
	// filesystems will be attempted. This setting is only used if
	// |run_postinstall| is set and true.
	FilesystemType string `protobuf:"bytes,4,opt,name=filesystem_type,json=filesystemType" json:"filesystem_type"`
	// If present, a list of signatures of the new_partition_info.hash signed with
	// different keys. If the update_engine daemon requires vendor-signed images
	// and has its public key installed, one of the signatures should be valid
	// for /postinstall to run.
	NewPartitionSignature []*Signatures_Signature `protobuf:"bytes,5,rep,name=new_partition_signature,json=newPartitionSignature" json:"new_partition_signature,omitempty"`
	OldPartitionInfo      *PartitionInfo          `protobuf:"bytes,6,opt,name=old_partition_info,json=oldPartitionInfo" json:"old_partition_info,omitempty"`
	NewPartitionInfo      *PartitionInfo          `protobuf:"bytes,7,opt,name=new_partition_info,json=newPartitionInfo" json:"new_partition_info,omitempty"`
	// The list of operations to be performed to apply this PartitionUpdate. The
	// associated operation blobs (in operations[i].data_offset, data_length)
	// should be stored contiguously and in the same order.
	Operations []*InstallOperation `protobuf:"bytes,8,rep,name=operations" json:"operations,omitempty"`
	// Whether a failure in the postinstall step for this partition should be
	// ignored.
	PostinstallOptional bool `protobuf:"varint,9,opt,name=postinstall_optional,json=postinstallOptional" json:"postinstall_optional"`
	// On minor version 6 or newer, these fields are supported:
	// The extent for data covered by verity hash tree.
	HashTreeDataExtent *Extent `protobuf:"bytes,10,opt,name=hash_tree_data_extent,json=hashTreeDataExtent" json:"hash_tree_data_extent,omitempty"`
	// The extent to store verity hash tree.
	HashTreeExtent *Extent `protobuf:"bytes,11,opt,name=hash_tree_extent,json=hashTreeExtent" json:"hash_tree_extent,omitempty"`
	// The hash algorithm used in verity hash tree.
	HashTreeAlgorithm string `protobuf:"bytes,12,opt,name=hash_tree_algorithm,json=hashTreeAlgorithm" json:"hash_tree_algorithm"`
	// The salt used for verity hash tree.
	HashTreeSalt []byte `protobuf:"bytes,13,opt,name=hash_tree_salt,json=hashTreeSalt" json:"hash_tree_salt"`
	// The extent for data covered by FEC.
	FecDataExtent *Extent `protobuf:"bytes,14,opt,name=fec_data_extent,json=fecDataExtent" json:"fec_data_extent,omitempty"`
	// The extent to store FEC.
	FecExtent *Extent `protobuf:"bytes,15,opt,name=fec_extent,json=fecExtent" json:"fec_extent,omitempty"`
	// The number of FEC roots.
	FecRoots *uint32 `protobuf:"varint,16,opt,name=fec_roots,json=fecRoots,def=2" json:"fec_roots,omitempty"`
	// Per-partition version used for downgrade detection, added
	// as an effort to support partial updates. For most partitions,
	// this is the build timestamp.
	Version string `protobuf:"bytes,17,opt,name=version" json:"version"`
	// A sorted list of CowMergeOperation. When writing cow, we can choose to
	// skip writing the raw bytes for these extents. During snapshot merge, the
	// bytes will read from the source partitions instead.
	MergeOperations []*CowMergeOperation `protobuf:"bytes,18,rep,name=merge_operations,json=mergeOperations" json:"merge_operations,omitempty"`
	// Estimated size for COW image. This is used by libsnapshot
	// as a hint. If set to 0, libsnapshot should use alternative
	// methods for estimating size.
	EstimateCowSize uint64 `protobuf:"varint,19,opt,name=estimate_cow_size,json=estimateCowSize" json:"estimate_cow_size"`
}

func (m *PartitionUpdate) Reset()      { *m = PartitionUpdate{} }
func (*PartitionUpdate) ProtoMessage() {}
func (*PartitionUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{5}
}
func (m *PartitionUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionUpdate.Merge(m, src)
}
func (m *PartitionUpdate) XXX_Size() int {
	return m.Size()
}
func (m *PartitionUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionUpdate proto.InternalMessageInfo

const Default_PartitionUpdate_FecRoots uint32 = 2

func (m *PartitionUpdate) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *PartitionUpdate) GetRunPostinstall() bool {
	if m != nil {
		return m.RunPostinstall
	}
	return false
}

func (m *PartitionUpdate) GetPostinstallPath() string {
	if m != nil {
		return m.PostinstallPath
	}
	return ""
}

func (m *PartitionUpdate) GetFilesystemType() string {
	if m != nil {
		return m.FilesystemType
	}
	return ""
}

func (m *PartitionUpdate) GetNewPartitionSignature() []*Signatures_Signature {
	if m != nil {
		return m.NewPartitionSignature
	}
	return nil
}

func (m *PartitionUpdate) GetOldPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.OldPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetNewPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.NewPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetOperations() []*InstallOperation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *PartitionUpdate) GetPostinstallOptional() bool {
	if m != nil {
		return m.PostinstallOptional
	}
	return false
}

func (m *PartitionUpdate) GetHashTreeDataExtent() *Extent {
	if m != nil {
		return m.HashTreeDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeExtent() *Extent {
	if m != nil {
		return m.HashTreeExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeAlgorithm() string {
	if m != nil {
		return m.HashTreeAlgorithm
	}
	return ""
}

func (m *PartitionUpdate) GetHashTreeSalt() []byte {
	if m != nil {
		return m.HashTreeSalt
	}
	return nil
}

func (m *PartitionUpdate) GetFecDataExtent() *Extent {
	if m != nil {
		return m.FecDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecExtent() *Extent {
	if m != nil {
		return m.FecExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecRoots() uint32 {
	if m != nil && m.FecRoots != nil {
		return *m.FecRoots
	}
	return Default_PartitionUpdate_FecRoots
}

func (m *PartitionUpdate) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *PartitionUpdate) GetMergeOperations() []*CowMergeOperation {
	if m != nil {
		return m.MergeOperations
	}
	return nil
}

func (m *PartitionUpdate) GetEstimateCowSize() uint64 {
	if m != nil {
		return m.EstimateCowSize
	}
	return 0
}

type DynamicPartitionGroup struct {
	// Name of the group.
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// Maximum size of the group. The sum of sizes of all partitions in the group
	// must not exceed the maximum size of the group.
	Size_ uint64 `protobuf:"varint,2,opt,name=size" json:"size"`
	// A list of partitions that belong to the group.
	PartitionNames []string `protobuf:"bytes,3,rep,name=partition_names,json=partitionNames" json:"partition_names,omitempty"`
}

func (m *DynamicPartitionGroup) Reset()      { *m = DynamicPartitionGroup{} }
func (*DynamicPartitionGroup) ProtoMessage() {}
func (*DynamicPartitionGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{6}
}
func (m *DynamicPartitionGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicPartitionGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicPartitionGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicPartitionGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicPartitionGroup.Merge(m, src)
}
func (m *DynamicPartitionGroup) XXX_Size() int {
	return m.Size()
}
func (m *DynamicPartitionGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicPartitionGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicPartitionGroup proto.InternalMessageInfo

func (m *DynamicPartitionGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DynamicPartitionGroup) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DynamicPartitionGroup) GetPartitionNames() []string {
	if m != nil {
		return m.PartitionNames
	}
	return nil
}

type VABCFeatureSet struct {
	Threaded    bool `protobuf:"varint,1,opt,name=threaded" json:"threaded"`
	BatchWrites bool `protobuf:"varint,2,opt,name=batch_writes,json=batchWrites" json:"batch_writes"`
}

func (m *VABCFeatureSet) Reset()      { *m = VABCFeatureSet{} }
func (*VABCFeatureSet) ProtoMessage() {}
func (*VABCFeatureSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{7}
}
func (m *VABCFeatureSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VABCFeatureSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VABCFeatureSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VABCFeatureSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VABCFeatureSet.Merge(m, src)
}
func (m *VABCFeatureSet) XXX_Size() int {
	return m.Size()
}
func (m *VABCFeatureSet) XXX_DiscardUnknown() {
	xxx_messageInfo_VABCFeatureSet.DiscardUnknown(m)
}

var xxx_messageInfo_VABCFeatureSet proto.InternalMessageInfo

func (m *VABCFeatureSet) GetThreaded() bool {
	if m != nil {
		return m.Threaded
	}
	return false
}

func (m *VABCFeatureSet) GetBatchWrites() bool {
	if m != nil {
		return m.BatchWrites
	}
	return false
}

// Metadata related to all dynamic partitions.
type DynamicPartitionMetadata struct {
	// All updatable groups present in |partitions| of this DeltaArchiveManifest.
	//   - If an updatable group is on the device but not in the manifest, it is
	//     not updated. Hence, the group will not be resized, and partitions cannot
	//     be added to or removed from the group.
	//   - If an updatable group is in the manifest but not on the device, the group
	//     is added to the device.
	Groups []*DynamicPartitionGroup `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	// Whether dynamic partitions have snapshots during the update. If this is
	// set to true, the update_engine daemon creates snapshots for all dynamic
	// partitions if possible. If this is unset, the update_engine daemon MUST
	// NOT create snapshots for dynamic partitions.
	SnapshotEnabled bool `protobuf:"varint,2,opt,name=snapshot_enabled,json=snapshotEnabled" json:"snapshot_enabled"`
	// If this is set to false, update_engine should not use VABC regardless. If
	// this is set to true, update_engine may choose to use VABC if device
	// supports it, but not guaranteed.
	// VABC stands for Virtual AB Compression
	VabcEnabled bool `protobuf:"varint,3,opt,name=vabc_enabled,json=vabcEnabled" json:"vabc_enabled"`
	// The compression algorithm used by VABC. Available ones are "gz", "brotli".
	// See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
	// as this parameter is ultimated forwarded to libsnapshot's CowWriter
	VabcCompressionParam string `protobuf:"bytes,4,opt,name=vabc_compression_param,json=vabcCompressionParam" json:"vabc_compression_param"`
	// COW version used by VABC. The represents the major version in the COW
	// header
	CowVersion uint32 `protobuf:"varint,5,opt,name=cow_version,json=cowVersion" json:"cow_version"`
	// A collection of knobs to tune Virtual AB Compression
	VabcFeatureSet *VABCFeatureSet `protobuf:"bytes,6,opt,name=vabc_feature_set,json=vabcFeatureSet" json:"vabc_feature_set,omitempty"`
}

func (m *DynamicPartitionMetadata) Reset()      { *m = DynamicPartitionMetadata{} }
func (*DynamicPartitionMetadata) ProtoMessage() {}
func (*DynamicPartitionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{8}
}
func (m *DynamicPartitionMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicPartitionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicPartitionMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicPartitionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicPartitionMetadata.Merge(m, src)
}
func (m *DynamicPartitionMetadata) XXX_Size() int {
	return m.Size()
}
func (m *DynamicPartitionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicPartitionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicPartitionMetadata proto.InternalMessageInfo

func (m *DynamicPartitionMetadata) GetGroups() []*DynamicPartitionGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *DynamicPartitionMetadata) GetSnapshotEnabled() bool {
	if m != nil {
		return m.SnapshotEnabled
	}
	return false
}

func (m *DynamicPartitionMetadata) GetVabcEnabled() bool {
	if m != nil {
		return m.VabcEnabled
	}
	return false
}

func (m *DynamicPartitionMetadata) GetVabcCompressionParam() string {
	if m != nil {
		return m.VabcCompressionParam
	}
	return ""
}

func (m *DynamicPartitionMetadata) GetCowVersion() uint32 {
	if m != nil {
		return m.CowVersion
	}
	return 0
}

func (m *DynamicPartitionMetadata) GetVabcFeatureSet() *VABCFeatureSet {
	if m != nil {
		return m.VabcFeatureSet
	}
	return nil
}

// Definition has been duplicated from
// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
type ApexInfo struct {
	PackageName      string `protobuf:"bytes,1,opt,name=package_name,json=packageName" json:"package_name"`
	Version          int64  `protobuf:"varint,2,opt,name=version" json:"version"`
	IsCompressed     bool   `protobuf:"varint,3,opt,name=is_compressed,json=isCompressed" json:"is_compressed"`
	DecompressedSize int64  `protobuf:"varint,4,opt,name=decompressed_size,json=decompressedSize" json:"decompressed_size"`
}

func (m *ApexInfo) Reset()      { *m = ApexInfo{} }
func (*ApexInfo) ProtoMessage() {}
func (*ApexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{9}
}
func (m *ApexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApexInfo.Merge(m, src)
}
func (m *ApexInfo) XXX_Size() int {
	return m.Size()
}
func (m *ApexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ApexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ApexInfo proto.InternalMessageInfo

func (m *ApexInfo) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *ApexInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ApexInfo) GetIsCompressed() bool {
	if m != nil {
		return m.IsCompressed
	}
	return false
}

func (m *ApexInfo) GetDecompressedSize() int64 {
	if m != nil {
		return m.DecompressedSize
	}
	return 0
}

// Definition has been duplicated from
// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
type ApexMetadata struct {
	ApexInfo []*ApexInfo `protobuf:"bytes,1,rep,name=apex_info,json=apexInfo" json:"apex_info,omitempty"`
}

func (m *ApexMetadata) Reset()      { *m = ApexMetadata{} }
func (*ApexMetadata) ProtoMessage() {}
func (*ApexMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{10}
}
func (m *ApexMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApexMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApexMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApexMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApexMetadata.Merge(m, src)
}
func (m *ApexMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ApexMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ApexMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ApexMetadata proto.InternalMessageInfo

func (m *ApexMetadata) GetApexInfo() []*ApexInfo {
	if m != nil {
		return m.ApexInfo
	}
	return nil
}

type DeltaArchiveManifest struct {
	// (At time of writing) usually 4096
	BlockSize *uint32 `protobuf:"varint,3,opt,name=block_size,json=blockSize,def=4096" json:"block_size,omitempty"`
	// If signatures are present, the offset into the blobs, generally
	// tacked onto the end of the file, and the length. We use an offset
	// rather than a bool to allow for more flexibility in future file formats.
	// If either is absent, it means signatures aren't supported in this
	// file.
	SignaturesOffset uint64 `protobuf:"varint,4,opt,name=signatures_offset,json=signaturesOffset" json:"signatures_offset"`
	SignaturesSize   uint64 `protobuf:"varint,5,opt,name=signatures_size,json=signaturesSize" json:"signatures_size"`
	// The minor version, also referred as "delta version", of the payload.
	// Minor version 0 is full payload, everything else is delta payload.
	MinorVersion *uint32 `protobuf:"varint,12,opt,name=minor_version,json=minorVersion,def=0" json:"minor_version,omitempty"`
	// Only present in major version >= 2. List of partitions that will be
	// updated, in the order they will be updated. This field replaces the
	// |install_operations|, |kernel_install_operations| and the
	// |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
	// array can have more than two partitions if needed, and they are identified
	// by the partition name.
	Partitions []*PartitionUpdate `protobuf:"bytes,13,rep,name=partitions" json:"partitions,omitempty"`
	// The maximum timestamp of the OS allowed to apply this payload.
	// Can be used to prevent downgrading the OS.
	MaxTimestamp int64 `protobuf:"varint,14,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp"`
	// Metadata related to all dynamic partitions.
	DynamicPartitionMetadata *DynamicPartitionMetadata `protobuf:"bytes,15,opt,name=dynamic_partition_metadata,json=dynamicPartitionMetadata" json:"dynamic_partition_metadata,omitempty"`
	// If the payload only updates a subset of partitions on the device.
	PartialUpdate bool `protobuf:"varint,16,opt,name=partial_update,json=partialUpdate" json:"partial_update"`
	// Information on compressed APEX to figure out how much space is required for
	// their decompression
	ApexInfo []*ApexInfo `protobuf:"bytes,17,rep,name=apex_info,json=apexInfo" json:"apex_info,omitempty"`
	// Security patch level of the device, usually in the format of
	// yyyy-mm-dd
	SecurityPatchLevel string `protobuf:"bytes,18,opt,name=security_patch_level,json=securityPatchLevel" json:"security_patch_level"`
}

func (m *DeltaArchiveManifest) Reset()      { *m = DeltaArchiveManifest{} }
func (*DeltaArchiveManifest) ProtoMessage() {}
func (*DeltaArchiveManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e043ea34d4b0b531, []int{11}
}
func (m *DeltaArchiveManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeltaArchiveManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeltaArchiveManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeltaArchiveManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeltaArchiveManifest.Merge(m, src)
}
func (m *DeltaArchiveManifest) XXX_Size() int {
	return m.Size()
}
func (m *DeltaArchiveManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeltaArchiveManifest.DiscardUnknown(m)
}

var xxx_messageInfo_DeltaArchiveManifest proto.InternalMessageInfo

const Default_DeltaArchiveManifest_BlockSize uint32 = 4096
const Default_DeltaArchiveManifest_MinorVersion uint32 = 0

func (m *DeltaArchiveManifest) GetBlockSize() uint32 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return Default_DeltaArchiveManifest_BlockSize
}

func (m *DeltaArchiveManifest) GetSignaturesOffset() uint64 {
	if m != nil {
		return m.SignaturesOffset
	}
	return 0
}

func (m *DeltaArchiveManifest) GetSignaturesSize() uint64 {
	if m != nil {
		return m.SignaturesSize
	}
	return 0
}

func (m *DeltaArchiveManifest) GetMinorVersion() uint32 {
	if m != nil && m.MinorVersion != nil {
		return *m.MinorVersion
	}
	return Default_DeltaArchiveManifest_MinorVersion
}

func (m *DeltaArchiveManifest) GetPartitions() []*PartitionUpdate {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *DeltaArchiveManifest) GetMaxTimestamp() int64 {
	if m != nil {
		return m.MaxTimestamp
	}
	return 0
}

func (m *DeltaArchiveManifest) GetDynamicPartitionMetadata() *DynamicPartitionMetadata {
	if m != nil {
		return m.DynamicPartitionMetadata
	}
	return nil
}

func (m *DeltaArchiveManifest) GetPartialUpdate() bool {
	if m != nil {
		return m.PartialUpdate
	}
	return false
}

func (m *DeltaArchiveManifest) GetApexInfo() []*ApexInfo {
	if m != nil {
		return m.ApexInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetSecurityPatchLevel() string {
	if m != nil {
		return m.SecurityPatchLevel
	}
	return ""
}

func init() {
	proto.RegisterEnum("chromeos_update_engine.InstallOperation_Type", InstallOperation_Type_name, InstallOperation_Type_value)
	proto.RegisterEnum("chromeos_update_engine.CowMergeOperation_Type", CowMergeOperation_Type_name, CowMergeOperation_Type_value)
	proto.RegisterType((*Extent)(nil), "chromeos_update_engine.Extent")
	proto.RegisterType((*Signatures)(nil), "chromeos_update_engine.Signatures")
	proto.RegisterType((*Signatures_Signature)(nil), "chromeos_update_engine.Signatures.Signature")
	proto.RegisterType((*PartitionInfo)(nil), "chromeos_update_engine.PartitionInfo")
	proto.RegisterType((*InstallOperation)(nil), "chromeos_update_engine.InstallOperation")
	proto.RegisterType((*CowMergeOperation)(nil), "chromeos_update_engine.CowMergeOperation")
	proto.RegisterType((*PartitionUpdate)(nil), "chromeos_update_engine.PartitionUpdate")
	proto.RegisterType((*DynamicPartitionGroup)(nil), "chromeos_update_engine.DynamicPartitionGroup")
	proto.RegisterType((*VABCFeatureSet)(nil), "chromeos_update_engine.VABCFeatureSet")
	proto.RegisterType((*DynamicPartitionMetadata)(nil), "chromeos_update_engine.DynamicPartitionMetadata")
	proto.RegisterType((*ApexInfo)(nil), "chromeos_update_engine.ApexInfo")
	proto.RegisterType((*ApexMetadata)(nil), "chromeos_update_engine.ApexMetadata")
	proto.RegisterType((*DeltaArchiveManifest)(nil), "chromeos_update_engine.DeltaArchiveManifest")
}

func init() { proto.RegisterFile("proto/update_metadata.proto", fileDescriptor_e043ea34d4b0b531) }

var fileDescriptor_e043ea34d4b0b531 = []byte{
	// 1694 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4f, 0x6f, 0xdc, 0xc6,
	0x15, 0x5f, 0xae, 0x28, 0x89, 0xfb, 0xf6, 0x1f, 0x35, 0x96, 0x13, 0xc2, 0x05, 0xb6, 0xc2, 0x16,
	0x89, 0x95, 0x36, 0x56, 0x5c, 0xc1, 0x75, 0x51, 0xa3, 0x46, 0x21, 0xad, 0x24, 0x4b, 0x82, 0x94,
	0xdd, 0x72, 0x65, 0x27, 0x55, 0x0f, 0xc4, 0x98, 0x9c, 0xd5, 0x12, 0xe1, 0x3f, 0x70, 0x66, 0x2d,
	0x29, 0xa7, 0x5e, 0x7a, 0xef, 0xc7, 0xe8, 0xa9, 0x40, 0x81, 0xde, 0xfa, 0x05, 0x72, 0xf4, 0x31,
	0xa7, 0xa2, 0x96, 0x51, 0xa0, 0x47, 0x7f, 0x81, 0x02, 0xc5, 0x0c, 0x39, 0xe4, 0xd0, 0xca, 0x22,
	0x9b, 0xdc, 0x76, 0xde, 0xff, 0x99, 0xf7, 0x7b, 0x3f, 0xbe, 0x85, 0x9f, 0x24, 0x69, 0xcc, 0xe2,
	0xcf, 0x66, 0x89, 0x87, 0x19, 0x71, 0x42, 0xc2, 0xb0, 0x87, 0x19, 0xde, 0x12, 0x52, 0xf4, 0x81,
	0x3b, 0x4d, 0xe3, 0x90, 0xc4, 0xd4, 0xc9, 0xf5, 0x24, 0xba, 0xf0, 0x23, 0xd2, 0x3f, 0x83, 0x95,
	0xfd, 0x2b, 0x46, 0x22, 0x86, 0x3e, 0x82, 0x26, 0x65, 0x38, 0x65, 0xce, 0xcb, 0x20, 0x76, 0xbf,
	0xb2, 0xb4, 0x0d, 0x6d, 0x53, 0xdf, 0xd5, 0xbf, 0xf9, 0xd7, 0x4f, 0x6b, 0x36, 0x08, 0xc5, 0x2e,
	0x97, 0xa3, 0x9f, 0x01, 0x44, 0xb3, 0x30, 0x33, 0xa2, 0x56, 0x5d, 0xb1, 0x6a, 0x44, 0xb3, 0x50,
	0xd8, 0xd0, 0xfe, 0x8d, 0x06, 0x30, 0xf6, 0x2f, 0x22, 0xcc, 0x66, 0x29, 0xa1, 0xe8, 0x04, 0x80,
	0x16, 0x27, 0x4b, 0xdb, 0x58, 0xda, 0x6c, 0x6e, 0x7f, 0xba, 0xf5, 0xdd, 0x15, 0x6d, 0x95, 0x7e,
	0xe5, 0x4f, 0x5b, 0xf1, 0xbf, 0xf7, 0x67, 0x0d, 0x1a, 0x85, 0x06, 0x6d, 0xc0, 0xea, 0x2b, 0x92,
	0x52, 0x3f, 0x8e, 0x44, 0xc9, 0xed, 0xdd, 0x15, 0x5e, 0x8c, 0xa5, 0xd9, 0x52, 0x8c, 0x2c, 0xd0,
	0xf9, 0x43, 0x88, 0x5a, 0x5b, 0x79, 0xad, 0x42, 0x82, 0x7e, 0x0b, 0x1f, 0xce, 0xa2, 0x04, 0x7b,
	0x1e, 0xf1, 0x9c, 0x22, 0x81, 0x43, 0xfd, 0xaf, 0x89, 0xb5, 0xb4, 0xa1, 0x6d, 0xae, 0xe6, 0xc6,
	0x77, 0xa5, 0x51, 0x91, 0x75, 0xec, 0x7f, 0x4d, 0xfa, 0x03, 0x68, 0x8f, 0x70, 0xca, 0x7c, 0xe6,
	0xc7, 0xd1, 0x51, 0x34, 0x89, 0x79, 0x22, 0xe1, 0xab, 0x3e, 0x9d, 0x90, 0x70, 0xcd, 0x14, 0xd3,
	0x69, 0xb5, 0x04, 0x2e, 0xe9, 0xff, 0x73, 0x19, 0xcc, 0xa3, 0x88, 0x32, 0x1c, 0x04, 0xc3, 0x84,
	0xa4, 0x98, 0x07, 0x43, 0xcf, 0x40, 0x67, 0xd7, 0x09, 0x0f, 0x54, 0xdf, 0xec, 0x6c, 0x3f, 0x98,
	0xf7, 0x52, 0xef, 0xfb, 0x6d, 0x9d, 0x5d, 0x27, 0x44, 0x46, 0xe7, 0x01, 0x78, 0x4f, 0xf9, 0x45,
	0x9d, 0x78, 0x32, 0xa1, 0x84, 0x55, 0xba, 0x05, 0x5c, 0x31, 0x14, 0xf2, 0xc2, 0x2c, 0x20, 0xd1,
	0x05, 0x9b, 0x8a, 0xbb, 0x57, 0xcc, 0x4e, 0x84, 0x1c, 0xfd, 0x0e, 0x9a, 0x34, 0x75, 0x1d, 0x22,
	0xf0, 0x42, 0x2d, 0x5d, 0xf4, 0xb1, 0x37, 0xaf, 0xba, 0x0c, 0x56, 0x36, 0xd0, 0xd4, 0xcd, 0x7e,
	0x52, 0x8e, 0x1d, 0x1e, 0x20, 0x4f, 0xb3, 0xac, 0x62, 0x87, 0xa6, 0x6e, 0x99, 0xc5, 0xa3, 0xac,
	0xc8, 0xb2, 0xb2, 0x58, 0x16, 0x8f, 0x32, 0x25, 0x0b, 0x0f, 0x90, 0x67, 0x59, 0x55, 0xb3, 0x78,
	0x94, 0xe5, 0x59, 0xb6, 0xc0, 0x14, 0x57, 0xa6, 0x53, 0xbc, 0xfd, 0xab, 0xc7, 0x8e, 0xe8, 0x8e,
	0xa1, 0x74, 0xa7, 0xc3, 0xb5, 0x63, 0xa1, 0x3c, 0xc4, 0x74, 0x8a, 0x3e, 0x85, 0x2e, 0x2f, 0x5d,
	0x35, 0x6f, 0x28, 0xe6, 0x6d, 0x9a, 0xba, 0xa5, 0x75, 0xff, 0x3f, 0x1a, 0xe8, 0xbc, 0x19, 0xa8,
	0x09, 0xab, 0xf6, 0xfe, 0xe8, 0x64, 0x67, 0xb0, 0x6f, 0xd6, 0x50, 0x07, 0x20, 0x3f, 0x38, 0xbb,
	0xe7, 0xa6, 0x86, 0x5a, 0xa0, 0x9f, 0x0e, 0x5f, 0xec, 0x9b, 0xf5, 0x7b, 0x75, 0x43, 0x43, 0x1d,
	0x58, 0xd9, 0x1d, 0xef, 0x1d, 0x1d, 0x1c, 0x98, 0x4b, 0xe2, 0xdc, 0x85, 0xe6, 0x78, 0xf8, 0xdc,
	0x1e, 0xec, 0x3b, 0x83, 0xe1, 0xe8, 0x0f, 0xa6, 0x8e, 0xd6, 0xa0, 0x9d, 0x0b, 0x72, 0xbb, 0x65,
	0x35, 0xe2, 0x97, 0xe7, 0xa6, 0x81, 0x0c, 0xd0, 0xcf, 0xf7, 0xed, 0xa1, 0xb9, 0xc2, 0x13, 0xef,
	0x1d, 0x8d, 0x07, 0x3b, 0xf6, 0x9e, 0xb9, 0xca, 0x3d, 0x77, 0xed, 0xe1, 0xd9, 0xc9, 0x91, 0xf4,
	0x04, 0xd4, 0x02, 0x63, 0xf4, 0xfc, 0xe0, 0x40, 0x9c, 0x1a, 0xfc, 0x74, 0xfe, 0x7c, 0x30, 0x38,
	0x3c, 0xfa, 0xfc, 0xc8, 0x6c, 0x22, 0x04, 0x9d, 0x93, 0xf3, 0x47, 0x5c, 0x25, 0xed, 0x5b, 0x68,
	0x1d, 0x4c, 0x29, 0x2b, 0xfc, 0xda, 0xfd, 0x7f, 0xd4, 0x61, 0x6d, 0x10, 0x5f, 0x9e, 0x92, 0xf4,
	0x82, 0x94, 0xf0, 0x3d, 0x2c, 0xe0, 0xab, 0x6d, 0x76, 0xb6, 0xb7, 0xe6, 0xb5, 0xee, 0x96, 0xe3,
	0x6d, 0xfc, 0x3e, 0xcd, 0x00, 0x93, 0x61, 0x41, 0xc0, 0xf7, 0xfb, 0xa1, 0xd0, 0x28, 0x00, 0xc7,
	0xdd, 0x4b, 0x28, 0x09, 0x58, 0x2f, 0xe0, 0x5e, 0x20, 0x49, 0xc2, 0x35, 0x1f, 0x1e, 0x5d, 0xb0,
	0x4b, 0x09, 0xd7, 0x6c, 0x76, 0xfa, 0xdb, 0x79, 0xa7, 0x5b, 0x60, 0x0c, 0x86, 0x5f, 0x64, 0xbd,
	0xaa, 0xf1, 0xe7, 0xe7, 0xa7, 0x2f, 0x87, 0xb6, 0x29, 0x3a, 0xc9, 0x0f, 0x12, 0x08, 0xf5, 0xfe,
	0xdf, 0x1a, 0xd0, 0x2d, 0xa8, 0xe3, 0xb9, 0xa8, 0x02, 0xfd, 0x02, 0x3a, 0x89, 0x14, 0x39, 0x11,
	0x0e, 0xb3, 0xe9, 0x6f, 0x48, 0x7c, 0x15, 0xba, 0xcf, 0x71, 0x48, 0xd0, 0x03, 0xe8, 0xa6, 0xb3,
	0xc8, 0x49, 0x62, 0xca, 0xfc, 0x8c, 0x04, 0xc4, 0xe3, 0x18, 0x12, 0xbc, 0xe9, 0x2c, 0x1a, 0x95,
	0x3a, 0xf4, 0x19, 0x98, 0x8a, 0xa9, 0x93, 0xe0, 0x7c, 0xc8, 0x65, 0xf4, 0xae, 0xa2, 0x1d, 0x61,
	0x36, 0xe5, 0xf1, 0x27, 0x7e, 0x40, 0xe8, 0x35, 0x65, 0x24, 0x74, 0x44, 0x33, 0x75, 0xc5, 0xbe,
	0x53, 0x2a, 0xc5, 0xdd, 0x3d, 0xf8, 0x30, 0x22, 0x97, 0x4e, 0x59, 0x7f, 0x41, 0xa6, 0xd6, 0xf2,
	0x8f, 0x20, 0xfb, 0xbb, 0x11, 0xb9, 0x2c, 0x9e, 0xa7, 0x64, 0xfa, 0x31, 0xa0, 0x38, 0xf0, 0x94,
	0x2c, 0x7e, 0x34, 0x89, 0xad, 0x15, 0xd1, 0xd5, 0x8f, 0xe6, 0x25, 0xa8, 0x30, 0xb4, 0x6d, 0xc6,
	0x81, 0x57, 0xe5, 0xec, 0x31, 0xa0, 0x6a, 0xe9, 0x22, 0xe8, 0xea, 0x0f, 0x0a, 0xaa, 0x96, 0x2b,
	0x82, 0x1e, 0x02, 0xc4, 0x12, 0xd4, 0xd4, 0x32, 0xc4, 0x13, 0x6c, 0x2e, 0xca, 0xe2, 0xb6, 0xe2,
	0x8b, 0x7e, 0x0d, 0xeb, 0x6a, 0xe7, 0xe2, 0x84, 0x8b, 0x71, 0x20, 0xb8, 0x47, 0x76, 0xfb, 0x8e,
	0x62, 0x31, 0xcc, 0x0d, 0xd0, 0xef, 0xe1, 0x2e, 0x27, 0x29, 0x87, 0xa5, 0x84, 0x38, 0x82, 0xe9,
	0xf2, 0x29, 0x80, 0x85, 0xa6, 0x00, 0x71, 0xe7, 0xb3, 0x94, 0x90, 0x3d, 0xcc, 0x70, 0x3e, 0x0e,
	0x87, 0x60, 0x96, 0x21, 0xf3, 0x68, 0xcd, 0x85, 0xa2, 0x75, 0x64, 0xb4, 0x3c, 0xd2, 0x23, 0xb8,
	0x53, 0x46, 0xc2, 0xc1, 0x45, 0x9c, 0xfa, 0x6c, 0x1a, 0x5a, 0x2d, 0x05, 0x62, 0x6b, 0xd2, 0x65,
	0x47, 0xaa, 0xd1, 0xcf, 0xa1, 0x53, 0x7a, 0x51, 0x1c, 0x30, 0xab, 0xad, 0x30, 0x70, 0x4b, 0x3a,
	0x8c, 0x71, 0xc0, 0xd0, 0x01, 0x74, 0x27, 0xc4, 0xad, 0x5c, 0xbc, 0xb3, 0x50, 0xa9, 0xed, 0x09,
	0x71, 0x95, 0x3b, 0x3f, 0x05, 0xe0, 0x71, 0xf2, 0x10, 0xdd, 0xc5, 0x18, 0x64, 0x42, 0x24, 0x01,
	0xf5, 0x80, 0x1f, 0x9c, 0x34, 0x8e, 0x19, 0xb5, 0x4c, 0x4e, 0x20, 0x4f, 0xb4, 0x6d, 0xdb, 0x98,
	0x10, 0xd7, 0xe6, 0x22, 0xd4, 0x2b, 0x97, 0x97, 0x35, 0xe5, 0xf2, 0xc5, 0xea, 0x72, 0x06, 0x66,
	0xc8, 0x29, 0xd2, 0x51, 0xe0, 0x84, 0x04, 0x9c, 0x3e, 0x59, 0x98, 0x55, 0xed, 0x6e, 0x58, 0x39,
	0x53, 0xf4, 0x10, 0xd6, 0x08, 0x65, 0x7e, 0xc8, 0xbd, 0xdc, 0xf8, 0x32, 0x5b, 0x78, 0xee, 0x28,
	0xdf, 0xc9, 0xae, 0x54, 0x0f, 0xe2, 0x4b, 0xb1, 0xea, 0x30, 0xb8, 0xbb, 0x77, 0x1d, 0xe1, 0xd0,
	0x77, 0x0b, 0xa0, 0x3f, 0x4b, 0xe3, 0x59, 0xc2, 0x17, 0x9b, 0x5b, 0x5c, 0x25, 0x24, 0xc5, 0x32,
	0x54, 0xbf, 0xb5, 0x0c, 0xdd, 0x87, 0x6e, 0x95, 0xe9, 0xa8, 0xb5, 0xb4, 0xb1, 0xb4, 0xd9, 0xb0,
	0x3b, 0x15, 0x92, 0xa3, 0xfd, 0x3f, 0x42, 0xe7, 0xc5, 0xce, 0xee, 0xe0, 0x80, 0x64, 0x3b, 0x17,
	0x61, 0x68, 0x03, 0x0c, 0x36, 0x4d, 0x09, 0xf6, 0x88, 0x27, 0xbe, 0x2e, 0x72, 0x04, 0x0a, 0x29,
	0xba, 0x0f, 0xad, 0x97, 0x98, 0xb9, 0x53, 0xe7, 0x32, 0xf5, 0x19, 0xa1, 0x15, 0x5a, 0x6c, 0x0a,
	0xcd, 0x17, 0x42, 0xd1, 0x7f, 0x57, 0x07, 0xeb, 0xfd, 0x3b, 0x9d, 0xe6, 0x3b, 0x33, 0xda, 0x87,
	0x95, 0x0b, 0x7e, 0x3f, 0xb9, 0xac, 0xce, 0x5d, 0xc1, 0xbe, 0xf3, 0x55, 0xec, 0xdc, 0x99, 0xf3,
	0x2e, 0x8d, 0x70, 0x42, 0xa7, 0x31, 0x73, 0x48, 0x84, 0x5f, 0x06, 0xc4, 0xab, 0x14, 0xd4, 0x95,
	0xda, 0xfd, 0x4c, 0xc9, 0xab, 0x7f, 0x85, 0x5f, 0xba, 0x85, 0xf1, 0x92, 0x5a, 0x3d, 0xd7, 0x48,
	0xc3, 0x27, 0xf0, 0x81, 0x30, 0x74, 0xe3, 0x30, 0x49, 0x09, 0xe5, 0x60, 0xe1, 0x1c, 0x86, 0xc3,
	0x0a, 0x4f, 0xaf, 0x73, 0x9b, 0x41, 0x69, 0x32, 0xe2, 0x16, 0x7c, 0xdb, 0xe3, 0x5d, 0x97, 0xc0,
	0x5b, 0x56, 0xbe, 0x6b, 0xe0, 0xc6, 0x97, 0x2f, 0x72, 0xec, 0x8d, 0xc0, 0x14, 0x29, 0x26, 0x24,
	0x5f, 0x8b, 0x09, 0xcb, 0xc9, 0xf6, 0xe3, 0x79, 0xaf, 0x51, 0xed, 0x96, 0xdd, 0xe1, 0xfe, 0xe5,
	0xb9, 0xff, 0x77, 0x0d, 0x8c, 0x9d, 0x84, 0x5c, 0x09, 0x8e, 0xbc, 0x0f, 0xad, 0x04, 0xbb, 0x5f,
	0xe1, 0x0b, 0x22, 0xbf, 0x76, 0x65, 0xdd, 0xcd, 0x5c, 0x23, 0xbe, 0x75, 0xca, 0x8c, 0xf0, 0xb7,
	0x5b, 0x7a, 0x7f, 0x46, 0x3e, 0x81, 0xb6, 0x4f, 0x8b, 0x87, 0x78, 0xef, 0xd1, 0x5a, 0x3e, 0x1d,
	0x14, 0x1a, 0xf4, 0x4b, 0x58, 0xf3, 0x48, 0x69, 0x99, 0x01, 0x5f, 0x57, 0x82, 0x9a, 0xaa, 0x5a,
	0x20, 0xff, 0x14, 0x5a, 0xbc, 0xe4, 0x02, 0x19, 0x4f, 0xa1, 0x81, 0x13, 0x72, 0x95, 0x7d, 0x26,
	0x32, 0x70, 0x6c, 0xcc, 0x7b, 0x0e, 0x79, 0x57, 0xdb, 0xc0, 0xf9, 0xaf, 0xfe, 0xff, 0x74, 0x58,
	0xdf, 0x23, 0x01, 0xc3, 0x3b, 0xa9, 0x3b, 0xf5, 0x5f, 0x91, 0x53, 0x1c, 0xf9, 0x13, 0x42, 0xc5,
	0xae, 0x21, 0xfe, 0x52, 0x95, 0xff, 0x3e, 0xda, 0x4f, 0xf4, 0x47, 0x0f, 0x7f, 0xf3, 0xd8, 0x6e,
	0x08, 0x39, 0x2f, 0x86, 0xd7, 0x5f, 0xfe, 0x0f, 0x52, 0xf7, 0x12, 0x39, 0x60, 0x66, 0xa9, 0xce,
	0x57, 0xfb, 0x07, 0xd0, 0x55, 0x5c, 0x44, 0x70, 0x75, 0xef, 0xee, 0x94, 0x4a, 0x91, 0xe1, 0x63,
	0x68, 0x87, 0x7e, 0x14, 0xa7, 0x05, 0x3a, 0x5a, 0x19, 0x69, 0x3d, 0xb4, 0x5b, 0x42, 0x2e, 0xc1,
	0xf1, 0x0c, 0xa0, 0x18, 0x56, 0x6a, 0xb5, 0xc5, 0x3b, 0xdc, 0xff, 0xde, 0xcf, 0x65, 0xb6, 0xea,
	0xd8, 0x8a, 0x2b, 0xef, 0x5e, 0x88, 0xaf, 0x1c, 0xe6, 0x87, 0x84, 0x32, 0x1c, 0x26, 0x82, 0xa6,
	0x65, 0x3b, 0x5a, 0x21, 0xbe, 0x3a, 0x93, 0x1a, 0x14, 0xc1, 0x3d, 0x2f, 0x1b, 0x37, 0xe5, 0x73,
	0x2d, 0xff, 0xe6, 0xe6, 0xdc, 0xfc, 0x70, 0xd1, 0x41, 0x95, 0x0d, 0xb5, 0x2d, 0x6f, 0x1e, 0x09,
	0xc8, 0x8d, 0x0c, 0x07, 0x79, 0x2c, 0xc1, 0xe0, 0x46, 0x65, 0x23, 0xc3, 0x41, 0xbe, 0xbe, 0x55,
	0x70, 0xb1, 0xf6, 0x43, 0x71, 0x81, 0x1e, 0xc3, 0x3a, 0x25, 0xee, 0x2c, 0xf5, 0xd9, 0x35, 0x5f,
	0xcf, 0xdc, 0xa9, 0x13, 0x90, 0x57, 0x24, 0xb0, 0x90, 0x32, 0x15, 0x48, 0x5a, 0x8c, 0xb8, 0xc1,
	0x09, 0xd7, 0x1f, 0xeb, 0x86, 0x66, 0xd6, 0x8f, 0x75, 0xa3, 0x6e, 0x2e, 0x1d, 0xeb, 0xc6, 0x8a,
	0xb9, 0x7a, 0xac, 0x1b, 0xab, 0xa6, 0x71, 0xac, 0x1b, 0x86, 0xd9, 0x38, 0xd6, 0x8d, 0x86, 0x09,
	0xc7, 0xba, 0x01, 0x66, 0xf3, 0x58, 0x37, 0x9a, 0x66, 0x6b, 0xf7, 0xd1, 0xeb, 0x37, 0xbd, 0xda,
	0xb7, 0x6f, 0x7a, 0xb5, 0x77, 0x6f, 0x7a, 0xda, 0x9f, 0x6e, 0x7a, 0xda, 0x5f, 0x6f, 0x7a, 0xda,
	0x37, 0x37, 0x3d, 0xed, 0xf5, 0x4d, 0x4f, 0xfb, 0xf7, 0x4d, 0x4f, 0xfb, 0xef, 0x4d, 0xaf, 0xf6,
	0xee, 0xa6, 0xa7, 0xfd, 0xe5, 0x6d, 0xaf, 0xf6, 0xfa, 0x6d, 0xaf, 0xf6, 0xed, 0xdb, 0x5e, 0xed,
	0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xce, 0xef, 0x81, 0x04, 0x5a, 0x10, 0x00, 0x00,
}

func (x InstallOperation_Type) String() string {
	s, ok := InstallOperation_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CowMergeOperation_Type) String() string {
	s, ok := CowMergeOperation_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Extent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Extent)
	if !ok {
		that2, ok := that.(Extent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartBlock != that1.StartBlock {
		return false
	}
	if this.NumBlocks != that1.NumBlocks {
		return false
	}
	return true
}
func (this *Signatures) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signatures)
	if !ok {
		that2, ok := that.(Signatures)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *Signatures_Signature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signatures_Signature)
	if !ok {
		that2, ok := that.(Signatures_Signature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.UnpaddedSignatureSize != that1.UnpaddedSignatureSize {
		return false
	}
	return true
}
func (this *PartitionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitionInfo)
	if !ok {
		that2, ok := that.(PartitionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *InstallOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallOperation)
	if !ok {
		that2, ok := that.(InstallOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.DataOffset != that1.DataOffset {
		return false
	}
	if this.DataLength != that1.DataLength {
		return false
	}
	if len(this.SrcExtents) != len(that1.SrcExtents) {
		return false
	}
	for i := range this.SrcExtents {
		if !this.SrcExtents[i].Equal(that1.SrcExtents[i]) {
			return false
		}
	}
	if this.SrcLength != that1.SrcLength {
		return false
	}
	if len(this.DstExtents) != len(that1.DstExtents) {
		return false
	}
	for i := range this.DstExtents {
		if !this.DstExtents[i].Equal(that1.DstExtents[i]) {
			return false
		}
	}
	if this.DstLength != that1.DstLength {
		return false
	}
	if !bytes.Equal(this.DataSha256Hash, that1.DataSha256Hash) {
		return false
	}
	if !bytes.Equal(this.SrcSha256Hash, that1.SrcSha256Hash) {
		return false
	}
	return true
}
func (this *CowMergeOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CowMergeOperation)
	if !ok {
		that2, ok := that.(CowMergeOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.SrcExtent.Equal(that1.SrcExtent) {
		return false
	}
	if !this.DstExtent.Equal(that1.DstExtent) {
		return false
	}
	if this.SrcOffset != that1.SrcOffset {
		return false
	}
	return true
}
func (this *PartitionUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitionUpdate)
	if !ok {
		that2, ok := that.(PartitionUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PartitionName != that1.PartitionName {
		return false
	}
	if this.RunPostinstall != that1.RunPostinstall {
		return false
	}
	if this.PostinstallPath != that1.PostinstallPath {
		return false
	}
	if this.FilesystemType != that1.FilesystemType {
		return false
	}
	if len(this.NewPartitionSignature) != len(that1.NewPartitionSignature) {
		return false
	}
	for i := range this.NewPartitionSignature {
		if !this.NewPartitionSignature[i].Equal(that1.NewPartitionSignature[i]) {
			return false
		}
	}
	if !this.OldPartitionInfo.Equal(that1.OldPartitionInfo) {
		return false
	}
	if !this.NewPartitionInfo.Equal(that1.NewPartitionInfo) {
		return false
	}
	if len(this.Operations) != len(that1.Operations) {
		return false
	}
	for i := range this.Operations {
		if !this.Operations[i].Equal(that1.Operations[i]) {
			return false
		}
	}
	if this.PostinstallOptional != that1.PostinstallOptional {
		return false
	}
	if !this.HashTreeDataExtent.Equal(that1.HashTreeDataExtent) {
		return false
	}
	if !this.HashTreeExtent.Equal(that1.HashTreeExtent) {
		return false
	}
	if this.HashTreeAlgorithm != that1.HashTreeAlgorithm {
		return false
	}
	if !bytes.Equal(this.HashTreeSalt, that1.HashTreeSalt) {
		return false
	}
	if !this.FecDataExtent.Equal(that1.FecDataExtent) {
		return false
	}
	if !this.FecExtent.Equal(that1.FecExtent) {
		return false
	}
	if this.FecRoots != nil && that1.FecRoots != nil {
		if *this.FecRoots != *that1.FecRoots {
			return false
		}
	} else if this.FecRoots != nil {
		return false
	} else if that1.FecRoots != nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if len(this.MergeOperations) != len(that1.MergeOperations) {
		return false
	}
	for i := range this.MergeOperations {
		if !this.MergeOperations[i].Equal(that1.MergeOperations[i]) {
			return false
		}
	}
	if this.EstimateCowSize != that1.EstimateCowSize {
		return false
	}
	return true
}
func (this *DynamicPartitionGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DynamicPartitionGroup)
	if !ok {
		that2, ok := that.(DynamicPartitionGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if len(this.PartitionNames) != len(that1.PartitionNames) {
		return false
	}
	for i := range this.PartitionNames {
		if this.PartitionNames[i] != that1.PartitionNames[i] {
			return false
		}
	}
	return true
}
func (this *VABCFeatureSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VABCFeatureSet)
	if !ok {
		that2, ok := that.(VABCFeatureSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Threaded != that1.Threaded {
		return false
	}
	if this.BatchWrites != that1.BatchWrites {
		return false
	}
	return true
}
func (this *DynamicPartitionMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DynamicPartitionMetadata)
	if !ok {
		that2, ok := that.(DynamicPartitionMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	if this.SnapshotEnabled != that1.SnapshotEnabled {
		return false
	}
	if this.VabcEnabled != that1.VabcEnabled {
		return false
	}
	if this.VabcCompressionParam != that1.VabcCompressionParam {
		return false
	}
	if this.CowVersion != that1.CowVersion {
		return false
	}
	if !this.VabcFeatureSet.Equal(that1.VabcFeatureSet) {
		return false
	}
	return true
}
func (this *ApexInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApexInfo)
	if !ok {
		that2, ok := that.(ApexInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PackageName != that1.PackageName {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.IsCompressed != that1.IsCompressed {
		return false
	}
	if this.DecompressedSize != that1.DecompressedSize {
		return false
	}
	return true
}
func (this *ApexMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApexMetadata)
	if !ok {
		that2, ok := that.(ApexMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ApexInfo) != len(that1.ApexInfo) {
		return false
	}
	for i := range this.ApexInfo {
		if !this.ApexInfo[i].Equal(that1.ApexInfo[i]) {
			return false
		}
	}
	return true
}
func (this *DeltaArchiveManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeltaArchiveManifest)
	if !ok {
		that2, ok := that.(DeltaArchiveManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BlockSize != nil && that1.BlockSize != nil {
		if *this.BlockSize != *that1.BlockSize {
			return false
		}
	} else if this.BlockSize != nil {
		return false
	} else if that1.BlockSize != nil {
		return false
	}
	if this.SignaturesOffset != that1.SignaturesOffset {
		return false
	}
	if this.SignaturesSize != that1.SignaturesSize {
		return false
	}
	if this.MinorVersion != nil && that1.MinorVersion != nil {
		if *this.MinorVersion != *that1.MinorVersion {
			return false
		}
	} else if this.MinorVersion != nil {
		return false
	} else if that1.MinorVersion != nil {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if !this.Partitions[i].Equal(that1.Partitions[i]) {
			return false
		}
	}
	if this.MaxTimestamp != that1.MaxTimestamp {
		return false
	}
	if !this.DynamicPartitionMetadata.Equal(that1.DynamicPartitionMetadata) {
		return false
	}
	if this.PartialUpdate != that1.PartialUpdate {
		return false
	}
	if len(this.ApexInfo) != len(that1.ApexInfo) {
		return false
	}
	for i := range this.ApexInfo {
		if !this.ApexInfo[i].Equal(that1.ApexInfo[i]) {
			return false
		}
	}
	if this.SecurityPatchLevel != that1.SecurityPatchLevel {
		return false
	}
	return true
}
func (this *Extent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&chromeos_update_engine.Extent{")
	s = append(s, "StartBlock: "+fmt.Sprintf("%#v", this.StartBlock)+",\n")
	s = append(s, "NumBlocks: "+fmt.Sprintf("%#v", this.NumBlocks)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Signatures) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&chromeos_update_engine.Signatures{")
	if this.Signatures != nil {
		s = append(s, "Signatures: "+fmt.Sprintf("%#v", this.Signatures)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Signatures_Signature) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&chromeos_update_engine.Signatures_Signature{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "UnpaddedSignatureSize: "+fmt.Sprintf("%#v", this.UnpaddedSignatureSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PartitionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&chromeos_update_engine.PartitionInfo{")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InstallOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&chromeos_update_engine.InstallOperation{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "DataOffset: "+fmt.Sprintf("%#v", this.DataOffset)+",\n")
	s = append(s, "DataLength: "+fmt.Sprintf("%#v", this.DataLength)+",\n")
	if this.SrcExtents != nil {
		s = append(s, "SrcExtents: "+fmt.Sprintf("%#v", this.SrcExtents)+",\n")
	}
	s = append(s, "SrcLength: "+fmt.Sprintf("%#v", this.SrcLength)+",\n")
	if this.DstExtents != nil {
		s = append(s, "DstExtents: "+fmt.Sprintf("%#v", this.DstExtents)+",\n")
	}
	s = append(s, "DstLength: "+fmt.Sprintf("%#v", this.DstLength)+",\n")
	s = append(s, "DataSha256Hash: "+fmt.Sprintf("%#v", this.DataSha256Hash)+",\n")
	s = append(s, "SrcSha256Hash: "+fmt.Sprintf("%#v", this.SrcSha256Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CowMergeOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&chromeos_update_engine.CowMergeOperation{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.SrcExtent != nil {
		s = append(s, "SrcExtent: "+fmt.Sprintf("%#v", this.SrcExtent)+",\n")
	}
	if this.DstExtent != nil {
		s = append(s, "DstExtent: "+fmt.Sprintf("%#v", this.DstExtent)+",\n")
	}
	s = append(s, "SrcOffset: "+fmt.Sprintf("%#v", this.SrcOffset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PartitionUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&chromeos_update_engine.PartitionUpdate{")
	s = append(s, "PartitionName: "+fmt.Sprintf("%#v", this.PartitionName)+",\n")
	s = append(s, "RunPostinstall: "+fmt.Sprintf("%#v", this.RunPostinstall)+",\n")
	s = append(s, "PostinstallPath: "+fmt.Sprintf("%#v", this.PostinstallPath)+",\n")
	s = append(s, "FilesystemType: "+fmt.Sprintf("%#v", this.FilesystemType)+",\n")
	if this.NewPartitionSignature != nil {
		s = append(s, "NewPartitionSignature: "+fmt.Sprintf("%#v", this.NewPartitionSignature)+",\n")
	}
	if this.OldPartitionInfo != nil {
		s = append(s, "OldPartitionInfo: "+fmt.Sprintf("%#v", this.OldPartitionInfo)+",\n")
	}
	if this.NewPartitionInfo != nil {
		s = append(s, "NewPartitionInfo: "+fmt.Sprintf("%#v", this.NewPartitionInfo)+",\n")
	}
	if this.Operations != nil {
		s = append(s, "Operations: "+fmt.Sprintf("%#v", this.Operations)+",\n")
	}
	s = append(s, "PostinstallOptional: "+fmt.Sprintf("%#v", this.PostinstallOptional)+",\n")
	if this.HashTreeDataExtent != nil {
		s = append(s, "HashTreeDataExtent: "+fmt.Sprintf("%#v", this.HashTreeDataExtent)+",\n")
	}
	if this.HashTreeExtent != nil {
		s = append(s, "HashTreeExtent: "+fmt.Sprintf("%#v", this.HashTreeExtent)+",\n")
	}
	s = append(s, "HashTreeAlgorithm: "+fmt.Sprintf("%#v", this.HashTreeAlgorithm)+",\n")
	s = append(s, "HashTreeSalt: "+fmt.Sprintf("%#v", this.HashTreeSalt)+",\n")
	if this.FecDataExtent != nil {
		s = append(s, "FecDataExtent: "+fmt.Sprintf("%#v", this.FecDataExtent)+",\n")
	}
	if this.FecExtent != nil {
		s = append(s, "FecExtent: "+fmt.Sprintf("%#v", this.FecExtent)+",\n")
	}
	if this.FecRoots != nil {
		s = append(s, "FecRoots: "+valueToGoStringUpdateMetadata(this.FecRoots, "uint32")+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.MergeOperations != nil {
		s = append(s, "MergeOperations: "+fmt.Sprintf("%#v", this.MergeOperations)+",\n")
	}
	s = append(s, "EstimateCowSize: "+fmt.Sprintf("%#v", this.EstimateCowSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DynamicPartitionGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&chromeos_update_engine.DynamicPartitionGroup{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	if this.PartitionNames != nil {
		s = append(s, "PartitionNames: "+fmt.Sprintf("%#v", this.PartitionNames)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VABCFeatureSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&chromeos_update_engine.VABCFeatureSet{")
	s = append(s, "Threaded: "+fmt.Sprintf("%#v", this.Threaded)+",\n")
	s = append(s, "BatchWrites: "+fmt.Sprintf("%#v", this.BatchWrites)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DynamicPartitionMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&chromeos_update_engine.DynamicPartitionMetadata{")
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "SnapshotEnabled: "+fmt.Sprintf("%#v", this.SnapshotEnabled)+",\n")
	s = append(s, "VabcEnabled: "+fmt.Sprintf("%#v", this.VabcEnabled)+",\n")
	s = append(s, "VabcCompressionParam: "+fmt.Sprintf("%#v", this.VabcCompressionParam)+",\n")
	s = append(s, "CowVersion: "+fmt.Sprintf("%#v", this.CowVersion)+",\n")
	if this.VabcFeatureSet != nil {
		s = append(s, "VabcFeatureSet: "+fmt.Sprintf("%#v", this.VabcFeatureSet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApexInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&chromeos_update_engine.ApexInfo{")
	s = append(s, "PackageName: "+fmt.Sprintf("%#v", this.PackageName)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "IsCompressed: "+fmt.Sprintf("%#v", this.IsCompressed)+",\n")
	s = append(s, "DecompressedSize: "+fmt.Sprintf("%#v", this.DecompressedSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApexMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&chromeos_update_engine.ApexMetadata{")
	if this.ApexInfo != nil {
		s = append(s, "ApexInfo: "+fmt.Sprintf("%#v", this.ApexInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeltaArchiveManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&chromeos_update_engine.DeltaArchiveManifest{")
	if this.BlockSize != nil {
		s = append(s, "BlockSize: "+valueToGoStringUpdateMetadata(this.BlockSize, "uint32")+",\n")
	}
	s = append(s, "SignaturesOffset: "+fmt.Sprintf("%#v", this.SignaturesOffset)+",\n")
	s = append(s, "SignaturesSize: "+fmt.Sprintf("%#v", this.SignaturesSize)+",\n")
	if this.MinorVersion != nil {
		s = append(s, "MinorVersion: "+valueToGoStringUpdateMetadata(this.MinorVersion, "uint32")+",\n")
	}
	if this.Partitions != nil {
		s = append(s, "Partitions: "+fmt.Sprintf("%#v", this.Partitions)+",\n")
	}
	s = append(s, "MaxTimestamp: "+fmt.Sprintf("%#v", this.MaxTimestamp)+",\n")
	if this.DynamicPartitionMetadata != nil {
		s = append(s, "DynamicPartitionMetadata: "+fmt.Sprintf("%#v", this.DynamicPartitionMetadata)+",\n")
	}
	s = append(s, "PartialUpdate: "+fmt.Sprintf("%#v", this.PartialUpdate)+",\n")
	if this.ApexInfo != nil {
		s = append(s, "ApexInfo: "+fmt.Sprintf("%#v", this.ApexInfo)+",\n")
	}
	s = append(s, "SecurityPatchLevel: "+fmt.Sprintf("%#v", this.SecurityPatchLevel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUpdateMetadata(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Extent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Extent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.NumBlocks))
	i--
	dAtA[i] = 0x10
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.StartBlock))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Signatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signatures_Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signatures_Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signatures_Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpaddedSignatureSize))
	i--
	dAtA[i] = 0x1d
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PartitionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Size_))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InstallOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SrcSha256Hash != nil {
		i -= len(m.SrcSha256Hash)
		copy(dAtA[i:], m.SrcSha256Hash)
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.SrcSha256Hash)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DataSha256Hash != nil {
		i -= len(m.DataSha256Hash)
		copy(dAtA[i:], m.DataSha256Hash)
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.DataSha256Hash)))
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.DstLength))
	i--
	dAtA[i] = 0x38
	if len(m.DstExtents) > 0 {
		for iNdEx := len(m.DstExtents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DstExtents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.SrcLength))
	i--
	dAtA[i] = 0x28
	if len(m.SrcExtents) > 0 {
		for iNdEx := len(m.SrcExtents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcExtents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.DataLength))
	i--
	dAtA[i] = 0x18
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.DataOffset))
	i--
	dAtA[i] = 0x10
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *CowMergeOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CowMergeOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CowMergeOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.SrcOffset))
	i--
	dAtA[i] = 0x20
	if m.DstExtent != nil {
		{
			size, err := m.DstExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcExtent != nil {
		{
			size, err := m.SrcExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PartitionUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.EstimateCowSize))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	if len(m.MergeOperations) > 0 {
		for iNdEx := len(m.MergeOperations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MergeOperations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.FecRoots != nil {
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(*m.FecRoots))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FecExtent != nil {
		{
			size, err := m.FecExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.FecDataExtent != nil {
		{
			size, err := m.FecDataExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.HashTreeSalt != nil {
		i -= len(m.HashTreeSalt)
		copy(dAtA[i:], m.HashTreeSalt)
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.HashTreeSalt)))
		i--
		dAtA[i] = 0x6a
	}
	i -= len(m.HashTreeAlgorithm)
	copy(dAtA[i:], m.HashTreeAlgorithm)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.HashTreeAlgorithm)))
	i--
	dAtA[i] = 0x62
	if m.HashTreeExtent != nil {
		{
			size, err := m.HashTreeExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.HashTreeDataExtent != nil {
		{
			size, err := m.HashTreeDataExtent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	i--
	if m.PostinstallOptional {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	if len(m.Operations) > 0 {
		for iNdEx := len(m.Operations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.NewPartitionInfo != nil {
		{
			size, err := m.NewPartitionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.OldPartitionInfo != nil {
		{
			size, err := m.OldPartitionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.NewPartitionSignature) > 0 {
		for iNdEx := len(m.NewPartitionSignature) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewPartitionSignature[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.FilesystemType)
	copy(dAtA[i:], m.FilesystemType)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.FilesystemType)))
	i--
	dAtA[i] = 0x22
	i -= len(m.PostinstallPath)
	copy(dAtA[i:], m.PostinstallPath)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.PostinstallPath)))
	i--
	dAtA[i] = 0x1a
	i--
	if m.RunPostinstall {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.PartitionName)
	copy(dAtA[i:], m.PartitionName)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.PartitionName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DynamicPartitionGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicPartitionGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicPartitionGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionNames) > 0 {
		for iNdEx := len(m.PartitionNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionNames[iNdEx])
			copy(dAtA[i:], m.PartitionNames[iNdEx])
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.PartitionNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Size_))
	i--
	dAtA[i] = 0x10
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VABCFeatureSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VABCFeatureSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VABCFeatureSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.BatchWrites {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i--
	if m.Threaded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DynamicPartitionMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicPartitionMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicPartitionMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VabcFeatureSet != nil {
		{
			size, err := m.VabcFeatureSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.CowVersion))
	i--
	dAtA[i] = 0x28
	i -= len(m.VabcCompressionParam)
	copy(dAtA[i:], m.VabcCompressionParam)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.VabcCompressionParam)))
	i--
	dAtA[i] = 0x22
	i--
	if m.VabcEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i--
	if m.SnapshotEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.DecompressedSize))
	i--
	dAtA[i] = 0x20
	i--
	if m.IsCompressed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x10
	i -= len(m.PackageName)
	copy(dAtA[i:], m.PackageName)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.PackageName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApexMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApexMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApexMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApexInfo) > 0 {
		for iNdEx := len(m.ApexInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApexInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeltaArchiveManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeltaArchiveManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeltaArchiveManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.SecurityPatchLevel)
	copy(dAtA[i:], m.SecurityPatchLevel)
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(len(m.SecurityPatchLevel)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	if len(m.ApexInfo) > 0 {
		for iNdEx := len(m.ApexInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApexInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	i--
	if m.PartialUpdate {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	if m.DynamicPartitionMetadata != nil {
		{
			size, err := m.DynamicPartitionMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.MaxTimestamp))
	i--
	dAtA[i] = 0x70
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdateMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.MinorVersion != nil {
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(*m.MinorVersion))
		i--
		dAtA[i] = 0x60
	}
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.SignaturesSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintUpdateMetadata(dAtA, i, uint64(m.SignaturesOffset))
	i--
	dAtA[i] = 0x20
	if m.BlockSize != nil {
		i = encodeVarintUpdateMetadata(dAtA, i, uint64(*m.BlockSize))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func encodeVarintUpdateMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovUpdateMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Extent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovUpdateMetadata(uint64(m.StartBlock))
	n += 1 + sovUpdateMetadata(uint64(m.NumBlocks))
	return n
}

func (m *Signatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	return n
}

func (m *Signatures_Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovUpdateMetadata(uint64(m.Version))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	n += 5
	return n
}

func (m *PartitionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovUpdateMetadata(uint64(m.Size_))
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	return n
}

func (m *InstallOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovUpdateMetadata(uint64(m.Type))
	n += 1 + sovUpdateMetadata(uint64(m.DataOffset))
	n += 1 + sovUpdateMetadata(uint64(m.DataLength))
	if len(m.SrcExtents) > 0 {
		for _, e := range m.SrcExtents {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 1 + sovUpdateMetadata(uint64(m.SrcLength))
	if len(m.DstExtents) > 0 {
		for _, e := range m.DstExtents {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 1 + sovUpdateMetadata(uint64(m.DstLength))
	if m.DataSha256Hash != nil {
		l = len(m.DataSha256Hash)
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.SrcSha256Hash != nil {
		l = len(m.SrcSha256Hash)
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	return n
}

func (m *CowMergeOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovUpdateMetadata(uint64(m.Type))
	if m.SrcExtent != nil {
		l = m.SrcExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.DstExtent != nil {
		l = m.DstExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	n += 1 + sovUpdateMetadata(uint64(m.SrcOffset))
	return n
}

func (m *PartitionUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	n += 2
	l = len(m.PostinstallPath)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	l = len(m.FilesystemType)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	if len(m.NewPartitionSignature) > 0 {
		for _, e := range m.NewPartitionSignature {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	if m.OldPartitionInfo != nil {
		l = m.OldPartitionInfo.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.NewPartitionInfo != nil {
		l = m.NewPartitionInfo.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 2
	if m.HashTreeDataExtent != nil {
		l = m.HashTreeDataExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.HashTreeExtent != nil {
		l = m.HashTreeExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	l = len(m.HashTreeAlgorithm)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	if m.HashTreeSalt != nil {
		l = len(m.HashTreeSalt)
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.FecDataExtent != nil {
		l = m.FecDataExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.FecExtent != nil {
		l = m.FecExtent.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	if m.FecRoots != nil {
		n += 2 + sovUpdateMetadata(uint64(*m.FecRoots))
	}
	l = len(m.Version)
	n += 2 + l + sovUpdateMetadata(uint64(l))
	if len(m.MergeOperations) > 0 {
		for _, e := range m.MergeOperations {
			l = e.Size()
			n += 2 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 2 + sovUpdateMetadata(uint64(m.EstimateCowSize))
	return n
}

func (m *DynamicPartitionGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	n += 1 + sovUpdateMetadata(uint64(m.Size_))
	if len(m.PartitionNames) > 0 {
		for _, s := range m.PartitionNames {
			l = len(s)
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	return n
}

func (m *VABCFeatureSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	return n
}

func (m *DynamicPartitionMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 2
	n += 2
	l = len(m.VabcCompressionParam)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	n += 1 + sovUpdateMetadata(uint64(m.CowVersion))
	if m.VabcFeatureSet != nil {
		l = m.VabcFeatureSet.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	return n
}

func (m *ApexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PackageName)
	n += 1 + l + sovUpdateMetadata(uint64(l))
	n += 1 + sovUpdateMetadata(uint64(m.Version))
	n += 2
	n += 1 + sovUpdateMetadata(uint64(m.DecompressedSize))
	return n
}

func (m *ApexMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApexInfo) > 0 {
		for _, e := range m.ApexInfo {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	return n
}

func (m *DeltaArchiveManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockSize != nil {
		n += 1 + sovUpdateMetadata(uint64(*m.BlockSize))
	}
	n += 1 + sovUpdateMetadata(uint64(m.SignaturesOffset))
	n += 1 + sovUpdateMetadata(uint64(m.SignaturesSize))
	if m.MinorVersion != nil {
		n += 1 + sovUpdateMetadata(uint64(*m.MinorVersion))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovUpdateMetadata(uint64(l))
		}
	}
	n += 1 + sovUpdateMetadata(uint64(m.MaxTimestamp))
	if m.DynamicPartitionMetadata != nil {
		l = m.DynamicPartitionMetadata.Size()
		n += 1 + l + sovUpdateMetadata(uint64(l))
	}
	n += 3
	if len(m.ApexInfo) > 0 {
		for _, e := range m.ApexInfo {
			l = e.Size()
			n += 2 + l + sovUpdateMetadata(uint64(l))
		}
	}
	l = len(m.SecurityPatchLevel)
	n += 2 + l + sovUpdateMetadata(uint64(l))
	return n
}

func sovUpdateMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUpdateMetadata(x uint64) (n int) {
	return sovUpdateMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Extent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Extent{`,
		`StartBlock:` + fmt.Sprintf("%v", this.StartBlock) + `,`,
		`NumBlocks:` + fmt.Sprintf("%v", this.NumBlocks) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Signatures) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSignatures := "[]*Signatures_Signature{"
	for _, f := range this.Signatures {
		repeatedStringForSignatures += strings.Replace(fmt.Sprintf("%v", f), "Signatures_Signature", "Signatures_Signature", 1) + ","
	}
	repeatedStringForSignatures += "}"
	s := strings.Join([]string{`&Signatures{`,
		`Signatures:` + repeatedStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *Signatures_Signature) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Signatures_Signature{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`UnpaddedSignatureSize:` + fmt.Sprintf("%v", this.UnpaddedSignatureSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PartitionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PartitionInfo{`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InstallOperation) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSrcExtents := "[]*Extent{"
	for _, f := range this.SrcExtents {
		repeatedStringForSrcExtents += strings.Replace(f.String(), "Extent", "Extent", 1) + ","
	}
	repeatedStringForSrcExtents += "}"
	repeatedStringForDstExtents := "[]*Extent{"
	for _, f := range this.DstExtents {
		repeatedStringForDstExtents += strings.Replace(f.String(), "Extent", "Extent", 1) + ","
	}
	repeatedStringForDstExtents += "}"
	s := strings.Join([]string{`&InstallOperation{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DataOffset:` + fmt.Sprintf("%v", this.DataOffset) + `,`,
		`DataLength:` + fmt.Sprintf("%v", this.DataLength) + `,`,
		`SrcExtents:` + repeatedStringForSrcExtents + `,`,
		`SrcLength:` + fmt.Sprintf("%v", this.SrcLength) + `,`,
		`DstExtents:` + repeatedStringForDstExtents + `,`,
		`DstLength:` + fmt.Sprintf("%v", this.DstLength) + `,`,
		`DataSha256Hash:` + fmt.Sprintf("%v", this.DataSha256Hash) + `,`,
		`SrcSha256Hash:` + fmt.Sprintf("%v", this.SrcSha256Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CowMergeOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CowMergeOperation{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`SrcExtent:` + strings.Replace(this.SrcExtent.String(), "Extent", "Extent", 1) + `,`,
		`DstExtent:` + strings.Replace(this.DstExtent.String(), "Extent", "Extent", 1) + `,`,
		`SrcOffset:` + fmt.Sprintf("%v", this.SrcOffset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PartitionUpdate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNewPartitionSignature := "[]*Signatures_Signature{"
	for _, f := range this.NewPartitionSignature {
		repeatedStringForNewPartitionSignature += strings.Replace(fmt.Sprintf("%v", f), "Signatures_Signature", "Signatures_Signature", 1) + ","
	}
	repeatedStringForNewPartitionSignature += "}"
	repeatedStringForOperations := "[]*InstallOperation{"
	for _, f := range this.Operations {
		repeatedStringForOperations += strings.Replace(f.String(), "InstallOperation", "InstallOperation", 1) + ","
	}
	repeatedStringForOperations += "}"
	repeatedStringForMergeOperations := "[]*CowMergeOperation{"
	for _, f := range this.MergeOperations {
		repeatedStringForMergeOperations += strings.Replace(f.String(), "CowMergeOperation", "CowMergeOperation", 1) + ","
	}
	repeatedStringForMergeOperations += "}"
	s := strings.Join([]string{`&PartitionUpdate{`,
		`PartitionName:` + fmt.Sprintf("%v", this.PartitionName) + `,`,
		`RunPostinstall:` + fmt.Sprintf("%v", this.RunPostinstall) + `,`,
		`PostinstallPath:` + fmt.Sprintf("%v", this.PostinstallPath) + `,`,
		`FilesystemType:` + fmt.Sprintf("%v", this.FilesystemType) + `,`,
		`NewPartitionSignature:` + repeatedStringForNewPartitionSignature + `,`,
		`OldPartitionInfo:` + strings.Replace(this.OldPartitionInfo.String(), "PartitionInfo", "PartitionInfo", 1) + `,`,
		`NewPartitionInfo:` + strings.Replace(this.NewPartitionInfo.String(), "PartitionInfo", "PartitionInfo", 1) + `,`,
		`Operations:` + repeatedStringForOperations + `,`,
		`PostinstallOptional:` + fmt.Sprintf("%v", this.PostinstallOptional) + `,`,
		`HashTreeDataExtent:` + strings.Replace(this.HashTreeDataExtent.String(), "Extent", "Extent", 1) + `,`,
		`HashTreeExtent:` + strings.Replace(this.HashTreeExtent.String(), "Extent", "Extent", 1) + `,`,
		`HashTreeAlgorithm:` + fmt.Sprintf("%v", this.HashTreeAlgorithm) + `,`,
		`HashTreeSalt:` + fmt.Sprintf("%v", this.HashTreeSalt) + `,`,
		`FecDataExtent:` + strings.Replace(this.FecDataExtent.String(), "Extent", "Extent", 1) + `,`,
		`FecExtent:` + strings.Replace(this.FecExtent.String(), "Extent", "Extent", 1) + `,`,
		`FecRoots:` + valueToStringUpdateMetadata(this.FecRoots) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`MergeOperations:` + repeatedStringForMergeOperations + `,`,
		`EstimateCowSize:` + fmt.Sprintf("%v", this.EstimateCowSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DynamicPartitionGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DynamicPartitionGroup{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`PartitionNames:` + fmt.Sprintf("%v", this.PartitionNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VABCFeatureSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VABCFeatureSet{`,
		`Threaded:` + fmt.Sprintf("%v", this.Threaded) + `,`,
		`BatchWrites:` + fmt.Sprintf("%v", this.BatchWrites) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DynamicPartitionMetadata) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroups := "[]*DynamicPartitionGroup{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "DynamicPartitionGroup", "DynamicPartitionGroup", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&DynamicPartitionMetadata{`,
		`Groups:` + repeatedStringForGroups + `,`,
		`SnapshotEnabled:` + fmt.Sprintf("%v", this.SnapshotEnabled) + `,`,
		`VabcEnabled:` + fmt.Sprintf("%v", this.VabcEnabled) + `,`,
		`VabcCompressionParam:` + fmt.Sprintf("%v", this.VabcCompressionParam) + `,`,
		`CowVersion:` + fmt.Sprintf("%v", this.CowVersion) + `,`,
		`VabcFeatureSet:` + strings.Replace(this.VabcFeatureSet.String(), "VABCFeatureSet", "VABCFeatureSet", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApexInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApexInfo{`,
		`PackageName:` + fmt.Sprintf("%v", this.PackageName) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`IsCompressed:` + fmt.Sprintf("%v", this.IsCompressed) + `,`,
		`DecompressedSize:` + fmt.Sprintf("%v", this.DecompressedSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApexMetadata) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForApexInfo := "[]*ApexInfo{"
	for _, f := range this.ApexInfo {
		repeatedStringForApexInfo += strings.Replace(f.String(), "ApexInfo", "ApexInfo", 1) + ","
	}
	repeatedStringForApexInfo += "}"
	s := strings.Join([]string{`&ApexMetadata{`,
		`ApexInfo:` + repeatedStringForApexInfo + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeltaArchiveManifest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPartitions := "[]*PartitionUpdate{"
	for _, f := range this.Partitions {
		repeatedStringForPartitions += strings.Replace(f.String(), "PartitionUpdate", "PartitionUpdate", 1) + ","
	}
	repeatedStringForPartitions += "}"
	repeatedStringForApexInfo := "[]*ApexInfo{"
	for _, f := range this.ApexInfo {
		repeatedStringForApexInfo += strings.Replace(f.String(), "ApexInfo", "ApexInfo", 1) + ","
	}
	repeatedStringForApexInfo += "}"
	s := strings.Join([]string{`&DeltaArchiveManifest{`,
		`BlockSize:` + valueToStringUpdateMetadata(this.BlockSize) + `,`,
		`SignaturesOffset:` + fmt.Sprintf("%v", this.SignaturesOffset) + `,`,
		`SignaturesSize:` + fmt.Sprintf("%v", this.SignaturesSize) + `,`,
		`MinorVersion:` + valueToStringUpdateMetadata(this.MinorVersion) + `,`,
		`Partitions:` + repeatedStringForPartitions + `,`,
		`MaxTimestamp:` + fmt.Sprintf("%v", this.MaxTimestamp) + `,`,
		`DynamicPartitionMetadata:` + strings.Replace(this.DynamicPartitionMetadata.String(), "DynamicPartitionMetadata", "DynamicPartitionMetadata", 1) + `,`,
		`PartialUpdate:` + fmt.Sprintf("%v", this.PartialUpdate) + `,`,
		`ApexInfo:` + repeatedStringForApexInfo + `,`,
		`SecurityPatchLevel:` + fmt.Sprintf("%v", this.SecurityPatchLevel) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringUpdateMetadata(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Extent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBlocks", wireType)
			}
			m.NumBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signatures_Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signatures_Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpaddedSignatureSize", wireType)
			}
			m.UnpaddedSignatureSize = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.UnpaddedSignatureSize = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallOperation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= InstallOperation_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataOffset", wireType)
			}
			m.DataOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcExtents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcExtents = append(m.SrcExtents, &Extent{})
			if err := m.SrcExtents[len(m.SrcExtents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcLength", wireType)
			}
			m.SrcLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstExtents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstExtents = append(m.DstExtents, &Extent{})
			if err := m.DstExtents[len(m.DstExtents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstLength", wireType)
			}
			m.DstLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSha256Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSha256Hash = append(m.DataSha256Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.DataSha256Hash == nil {
				m.DataSha256Hash = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSha256Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcSha256Hash = append(m.SrcSha256Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcSha256Hash == nil {
				m.SrcSha256Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CowMergeOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CowMergeOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CowMergeOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CowMergeOperation_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcExtent == nil {
				m.SrcExtent = &Extent{}
			}
			if err := m.SrcExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstExtent == nil {
				m.DstExtent = &Extent{}
			}
			if err := m.DstExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcOffset", wireType)
			}
			m.SrcOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionUpdate) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunPostinstall", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunPostinstall = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostinstallPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostinstallPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesystemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilesystemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPartitionSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPartitionSignature = append(m.NewPartitionSignature, &Signatures_Signature{})
			if err := m.NewPartitionSignature[len(m.NewPartitionSignature)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPartitionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldPartitionInfo == nil {
				m.OldPartitionInfo = &PartitionInfo{}
			}
			if err := m.OldPartitionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPartitionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewPartitionInfo == nil {
				m.NewPartitionInfo = &PartitionInfo{}
			}
			if err := m.NewPartitionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operations = append(m.Operations, &InstallOperation{})
			if err := m.Operations[len(m.Operations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostinstallOptional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PostinstallOptional = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashTreeDataExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashTreeDataExtent == nil {
				m.HashTreeDataExtent = &Extent{}
			}
			if err := m.HashTreeDataExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashTreeExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashTreeExtent == nil {
				m.HashTreeExtent = &Extent{}
			}
			if err := m.HashTreeExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashTreeAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashTreeAlgorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashTreeSalt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashTreeSalt = append(m.HashTreeSalt[:0], dAtA[iNdEx:postIndex]...)
			if m.HashTreeSalt == nil {
				m.HashTreeSalt = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecDataExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FecDataExtent == nil {
				m.FecDataExtent = &Extent{}
			}
			if err := m.FecDataExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecExtent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FecExtent == nil {
				m.FecExtent = &Extent{}
			}
			if err := m.FecExtent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecRoots", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FecRoots = &v
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeOperations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MergeOperations = append(m.MergeOperations, &CowMergeOperation{})
			if err := m.MergeOperations[len(m.MergeOperations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimateCowSize", wireType)
			}
			m.EstimateCowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimateCowSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("partition_name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicPartitionGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicPartitionGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicPartitionGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionNames = append(m.PartitionNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VABCFeatureSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VABCFeatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VABCFeatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Threaded = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchWrites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchWrites = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicPartitionMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicPartitionMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicPartitionMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &DynamicPartitionGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VabcEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VabcEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VabcCompressionParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VabcCompressionParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CowVersion", wireType)
			}
			m.CowVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CowVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VabcFeatureSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VabcFeatureSet == nil {
				m.VabcFeatureSet = &VABCFeatureSet{}
			}
			if err := m.VabcFeatureSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCompressed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCompressed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecompressedSize", wireType)
			}
			m.DecompressedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecompressedSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApexMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApexMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApexMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApexInfo = append(m.ApexInfo, &ApexInfo{})
			if err := m.ApexInfo[len(m.ApexInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaArchiveManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaArchiveManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaArchiveManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignaturesOffset", wireType)
			}
			m.SignaturesOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignaturesOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignaturesSize", wireType)
			}
			m.SignaturesSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignaturesSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorVersion = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &PartitionUpdate{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			m.MaxTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicPartitionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicPartitionMetadata == nil {
				m.DynamicPartitionMetadata = &DynamicPartitionMetadata{}
			}
			if err := m.DynamicPartitionMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartialUpdate = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApexInfo = append(m.ApexInfo, &ApexInfo{})
			if err := m.ApexInfo[len(m.ApexInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPatchLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPatchLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdateMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdateMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpdateMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpdateMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdateMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUpdateMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUpdateMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUpdateMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUpdateMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpdateMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUpdateMetadata = fmt.Errorf("proto: unexpected end of group")
)
