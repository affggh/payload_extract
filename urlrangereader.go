package payload_extract_go

// Generated by Google Gemini 2.5 preview

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"
	"sync"
)

type ReaderAtCloser interface {
	ReadAt([]byte, int64) (int, error)
	Close() error
}

// Define a default User-Agent string to simulate a browser with oppo header
const defaultUserAgent = "Dalvik/2.1.0 (Linux; U; Android 15; RMX5010 Build/AP3A.240617.008)"

// UrlRangeReaderAt reads data from a URL supporting HTTP Range requests.
// It implements io.ReaderAt and attempts to reuse the underlying HTTP stream
// for consecutive ReadAt calls to improve performance on sequential patterns.
type UrlRangeReaderAt struct {
	url string

	total int64
	// mu protects access to the stream, streamNextBytePos, and client fields.
	// url is assumed immutable after creation.
	mu     sync.Mutex
	client http.Client

	// State for potential stream reuse in ReadAt
	stream            io.ReadCloser // The active response body if reusing
	streamNextBytePos int64         // The absolute offset of the *next byte* expected from 'stream'
}

func (r *UrlRangeReaderAt) Size() int64 {
	return r.total
}

// NewUrlRangeReaderAt creates a new UrlRangeReaderAt for the given URL.
// It uses a default http.Client.
func NewUrlRangeReaderAt(url string) *UrlRangeReaderAt {
	defaultClient := http.Client{
		//Timeout: 30 * time.Second, // Example timeout
	}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatalln(err)
	}
	req.Header.Add("User-Agent", defaultUserAgent)

	resp, err := defaultClient.Do(req)
	if err != nil {
		Logger.Fatalln(err)
	}
	//fmt.Printf("Header: %v Code:%d\n", resp.Header, resp.StatusCode)

	total, err := strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)
	if err != nil {
		Logger.Fatalln(err)
	}

	return &UrlRangeReaderAt{
		url:    url,
		client: defaultClient,
		total:  total,
		// stream starts as nil
		// streamNextBytePos starts at 0
	}
}

func (r *UrlRangeReaderAt) Close() error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if r.stream != nil {
		r.Close()
		r.stream = nil
	}

	return nil
}

// ReadAt implements the io.ReaderAt interface.
// It reads len(p) bytes from the URL starting at byte offset off.
// It attempts to reuse the internal stream if 'off' is contiguous
// with the end of the previous read from the stream.
func (r *UrlRangeReaderAt) ReadAt(p []byte, off int64) (n int, err error) {
	if len(p) == 0 {
		return 0, nil // As per io.ReaderAt contract
	}

	r.mu.Lock() // Lock at the start

	// --- Attempt Stream Reuse ---
	// Check if we have an active stream AND the requested offset 'off'
	// is exactly where the current stream expects the next byte.
	if r.stream != nil && off == r.streamNextBytePos {
		// The request is contiguous with the current stream.
		// Release the mutex BEFORE reading from the stream (I/O operation).
		r.mu.Unlock()

		// Read from the existing stream.
		n, err = io.ReadFull(r.stream, p) // Try to fill buffer p

		// Re-acquire the mutex AFTER reading.
		r.mu.Lock()         // Lock again to update stream state and handle potential closure
		defer r.mu.Unlock() // Ensure mutex is released on function exit path

		// Update the next expected position *from this stream*.
		r.streamNextBytePos += int64(n)

		// If reading from the stream resulted in an error (including io.EOF)
		// or was a partial read not hitting EOF (ErrUnexpectedEOF), close the stream.
		if err != nil {
			if err == io.ErrUnexpectedEOF {
				err = io.EOF // Convert ReadFull's specific error to io.EOF
			}
			r.stream.Close()
			r.stream = nil
		}

		return n, err // Propagate the result (n bytes, possible io.EOF or other error)

	} else {
		// --- Cannot Reuse Stream or Not Contiguous ---
		// If there was an old stream, close it before opening a new one.
		if r.stream != nil {
			r.stream.Close()
			r.stream = nil
		}
		// Mutex is still locked here.

		// Release the mutex BEFORE making the new HTTP request (I/O operation).
		r.mu.Unlock()

		// Make a new HTTP request for the specific range.
		req, httpErr := http.NewRequest("GET", r.url, nil)
		if httpErr != nil {
			return 0, fmt.Errorf("UrlRangeReaderAt.ReadAt: failed to create request for offset %d: %w", off, httpErr)
		}

		req.Header.Del("Accept-Encoding") // sick oppo
		// Set the Range header: bytes=start-end (inclusive)
		endOff := off + int64(len(p)) - 1
		req.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", off, endOff))

		// --- Add User-Agent header here ---
		req.Header.Set("User-Agent", defaultUserAgent)

		resp, httpErr := r.client.Do(req)
		if httpErr != nil {
			return 0, fmt.Errorf("UrlRangeReaderAt.ReadAt: failed to perform request for offset %d: %w", off, httpErr)
		}
		defer resp.Body.Close() // Ensure this response body is closed

		// Process the response for the new connection
		switch resp.StatusCode {
		case http.StatusPartialContent: // 206 Partial Content - Success!
			// Read the requested data into p.
			n, readErr := io.ReadFull(resp.Body, p)

			if readErr == io.ErrUnexpectedEOF {
				readErr = io.EOF // Convert ReadFull's specific error
			} else if readErr != nil {
				return n, fmt.Errorf("UrlRangeReaderAt.ReadAt: failed to read response body for offset %d: %w", off, readErr)
			}
			return n, readErr // Return result from the new connection

		case http.StatusOK: // 200 OK
			// If server returns 200 for a range request, it likely ignored the range.
			// Treat this as an error as it doesn't fit the RangeReaderAt model.
			return 0, fmt.Errorf("UrlRangeReaderAt.ReadAt: server returned 200 OK for offset %d range. Does not support Range requests or ignored header", off)

		case http.StatusRequestedRangeNotSatisfiable: // 416 Range Not Satisfiable
			return 0, io.EOF

		default: // Other HTTP status codes indicate an error
			return 0, fmt.Errorf("UrlRangeReaderAt.ReadAt: received unexpected HTTP status for offset %d range: %s", off, resp.Status)
		}
	}
}
